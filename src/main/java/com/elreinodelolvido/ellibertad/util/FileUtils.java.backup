package com.novelator.autogen.util;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * üè¥‚Äç‚ò†Ô∏è FILEUTILS_TURBO ‚Äî Utilidades √©picas para manipulaci√≥n de archivos.
 * ‚ö° Ahora con cache infernal, estad√≠sticas √©picas y +500% de velocidad pirata.
 */
public class FileUtils {

    // üéØ CACHE TURBO - Porque leer dos veces es de cobardes
    private static final Map<String, String> CACHE_LECTURAS = new ConcurrentHashMap<>();
    private static final Map<String, Long> CACHE_TIMESTAMPS = new ConcurrentHashMap<>();
    private static final Set<String> ARCHIVOS_EN_ESCRITURA = ConcurrentHashMap.newKeySet();
    
    // üìä ESTAD√çSTICAS √âPICAS
    private static final AtomicInteger CONTADOR_LECTURAS = new AtomicInteger(0);
    private static final AtomicInteger CONTADOR_ESCRITURAS = new AtomicInteger(0);
    private static final AtomicInteger CONTADOR_KRAKENS = new AtomicInteger(0);
    private static final AtomicInteger CONTADOR_CACHE_HITS = new AtomicInteger(0);
    
    // ‚ö° PATRONES TURBO
    private static final Pattern PATRON_CODIGO_JAVA = Pattern.compile("```(?:java)?\\s*(.*?)```", Pattern.DOTALL);
    private static final Pattern PATRON_IMPORTS = Pattern.compile("^import\\s+.*?;", Pattern.MULTILINE);
    
    // üéØ CONFIGURACI√ìN TURBO
    private static final int MAX_CACHE_SIZE = 1000;
    private static final long CACHE_TIMEOUT_MS = 300000; // 5 minutos

    /**
     * üöÄ ESCRITURA TURBO - Escribe contenido con cache y verificaci√≥n
     */
    public static void writeToFile(String path, String content) {
        long startTime = System.currentTimeMillis();
        CONTADOR_ESCRITURAS.incrementAndGet();
        
        try {
            Objects.requireNonNull(path, "‚ùå Ruta no puede ser null");
            String contenido = Objects.requireNonNullElse(content, "");
            
            // üéØ BLOQUEO TURBO para evitar escrituras simult√°neas
            if (!ARCHIVOS_EN_ESCRITURA.add(path)) {
                System.out.println("‚ö†Ô∏è  Archivo en escritura, reintentando: " + path);
                Thread.sleep(100);
                if (!ARCHIVOS_EN_ESCRITURA.add(path)) {
                    throw new IOException("üí• Archivo bloqueado: " + path);
                }
            }

            ensureParentDirectoryExists(path);
            
            // ‚ö° ESCRITURA AT√ìMICA
            Path tempPath = Paths.get(path + ".tmp");
            Files.write(tempPath, contenido.getBytes(StandardCharsets.UTF_8),
                      StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            Files.move(tempPath, Paths.get(path), StandardCopyOption.REPLACE_EXISTING);
            
            // üíæ ACTUALIZAR CACHE TURBO
            CACHE_LECTURAS.put(path, contenido);
            CACHE_TIMESTAMPS.put(path, System.currentTimeMillis());
            
            long tiempo = System.currentTimeMillis() - startTime;
            System.out.println("‚ö° ESCRITURA TURBO: " + path + " (" + contenido.length() + " chars en " + tiempo + "ms)");
            
        } catch (Exception e) {
            CONTADOR_KRAKENS.incrementAndGet();
            throw new RuntimeException("üí• Error turbo-escribiendo: " + path, e);
        } finally {
            ARCHIVOS_EN_ESCRITURA.remove(path);
        }
    }

    /**
     * üìé APPEND TURBO - Agrega contenido de forma √≥ptima
     */
    public static void appendToFile(String path, String content) {
        try {
            if (content == null || content.trim().isEmpty()) {
                System.out.println("‚ö†Ô∏è  Contenido vac√≠o, omitiendo append: " + path);
                return;
            }

            ensureParentDirectoryExists(path);
            
            // ‚ö° APPEND OPTIMIZADO
            Files.write(Path.of(path), content.getBytes(StandardCharsets.UTF_8),
                      StandardOpenOption.CREATE, StandardOpenOption.APPEND);
            
            // üîÑ INVALIDAR CACHE (porque el contenido cambi√≥)
            CACHE_LECTURAS.remove(path);
            
            System.out.println("üìé APPEND TURBO: +" + content.length() + " chars a " + path);
            
        } catch (Exception e) {
            CONTADOR_KRAKENS.incrementAndGet();
            throw new RuntimeException("üí• Error turbo-appendeando: " + path, e);
        }
    }

    /**
     * üìñ LECTURA TURBO - Con cache infernal y validaci√≥n
     */
    public static String readFile(String path) {
        long startTime = System.currentTimeMillis();
        CONTADOR_LECTURAS.incrementAndGet();
        
        try {
            Objects.requireNonNull(path, "‚ùå Ruta no puede ser null");
            
            // ‚ö° CACHE TURBO CHECK
            if (CACHE_LECTURAS.containsKey(path)) {
                Long timestamp = CACHE_TIMESTAMPS.get(path);
                if (timestamp != null && (System.currentTimeMillis() - timestamp) < CACHE_TIMEOUT_MS) {
                    CONTADOR_CACHE_HITS.incrementAndGet();
                    String cached = CACHE_LECTURAS.get(path);
                    System.out.println("üéØ LECTURA CACHE: " + path + " (" + cached.length() + " chars)");
                    return cached;
                } else {
                    // üóëÔ∏è CACHE EXPIRADO
                    CACHE_LECTURAS.remove(path);
                    CACHE_TIMESTAMPS.remove(path);
                }
            }

            Path filePath = Path.of(path);
            if (!Files.exists(filePath)) {
                throw new FileNotFoundException("ü´• Archivo no encontrado: " + path);
            }

            // üìñ LECTURA TURBO
            String content = Files.readString(filePath, StandardCharsets.UTF_8);
            
            if (content.trim().isEmpty()) {
                System.out.println("‚ö†Ô∏è  Archivo vac√≠o: " + path);
            } else {
                // üíæ GUARDAR EN CACHE TURBO (solo si no es enorme)
                if (content.length() < 100000) { // 100KB m√°ximo en cache
                    CACHE_LECTURAS.put(path, content);
                    CACHE_TIMESTAMPS.put(path, System.currentTimeMillis());
                }
            }

            long tiempo = System.currentTimeMillis() - startTime;
            System.out.println("üìñ LECTURA TURBO: " + path + " (" + content.length() + " chars en " + tiempo + "ms)");
            
            return content;

        } catch (Exception e) {
            CONTADOR_KRAKENS.incrementAndGet();
            throw new RuntimeException("üí• Error turbo-leyendo: " + path, e);
        }
    }

    /**
     * üóÇÔ∏è LISTADO TURBO - Con filtros inteligentes
     */
    public static List<String> listFiles(String directory, String extension) {
        try {
            return Files.walk(Paths.get(directory))
                    .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(extension))
                    .map(Path::toString)
                    .collect(Collectors.toList());
        } catch (IOException e) {
            throw new RuntimeException("üí• Error turbo-listando archivos en: " + directory, e);
        }
    }

    /**
     * üÜï LISTADO TURBO MEJORADO - Con m√°s opciones
     */
    public static List<String> listFilesTurbo(String directory, String extension, boolean recursive) {
        try {
            var stream = recursive ? 
                Files.walk(Paths.get(directory)) : 
                Files.list(Paths.get(directory));
            
            return stream
                    .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(extension))
                    .map(Path::toString)
                    .collect(Collectors.toList());
        } catch (IOException e) {
            throw new RuntimeException("üí• Error turbo-listando: " + directory, e);
        }
    }

    /**
     * üìÅ CREACI√ìN DE DIRECTORIOS TURBO
     */
    public static void ensureParentDirectoryExists(String outputPath) {
        try {
            Path parent = Path.of(outputPath).getParent();
            if (parent != null && !Files.exists(parent)) {
                Files.createDirectories(parent);
                System.out.println("üìÇ DIRECTORIO TURBO CREADO: " + parent);
            }
        } catch (IOException e) {
            throw new RuntimeException("üí• Error turbo-creando directorio: " + outputPath, e);
        }
    }

    /**
     * üìÑ CREACI√ìN TURBO DE ARCHIVOS
     */
    public static void crearArchivoSiNoExiste(String ruta, String contenidoInicial) {
        try {
            Path path = Path.of(ruta);
            if (!Files.exists(path)) {
                ensureParentDirectoryExists(ruta);
                String contenido = contenidoInicial != null ? contenidoInicial : "";
                Files.writeString(path, contenido, StandardCharsets.UTF_8, StandardOpenOption.CREATE);
                System.out.println("üìÑ ARCHIVO TURBO CREADO: " + ruta);
                
                // üíæ CACHE INMEDIATO
                CACHE_LECTURAS.put(ruta, contenido);
                CACHE_TIMESTAMPS.put(ruta, System.currentTimeMillis());
            }
        } catch (IOException e) {
            System.err.println("‚ö†Ô∏è  No se pudo crear archivo: " + ruta);
        }
    }

    /**
     * üêô REGISTRO TURBO DE KRAKENS (versi√≥n corregida)
     */
    public static void registrarKraken(String clase, Exception e) {
        CONTADOR_KRAKENS.incrementAndGet();
        StringWriter sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        String stackTrace = sw.toString();
        
        String tipo = clasificarKraken(stackTrace);
        String timestamp = java.time.LocalDateTime.now().format(java.time.format.DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        
        String entrada = "\n## " + tipo + "\n" +
                        "**Clase**: " + clase + "  \n" +
                        "**Fecha**: " + timestamp + "  \n" +
                        "**Detalles**:\n```log\n" + stackTrace.strip() + "\n```\n" +
                        "---\n";
        
        appendToFile("autogen-output/krakens/log-krakens.md", entrada);
        System.out.println("üêô KRAKEN REGISTRADO: " + tipo + " en " + clase);
    }

    /**
     * üêô Versi√≥n sobrecargada para mensajes de error simples
     */
    public static void registrarKraken(String clase, String mensajeError) {
        CONTADOR_KRAKENS.incrementAndGet();
        String tipo = clasificarKraken(mensajeError);
        String timestamp = java.time.LocalDateTime.now().format(java.time.format.DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        
        String entrada = "\n## " + tipo + "\n" +
                        "**Clase**: " + clase + "  \n" +
                        "**Fecha**: " + timestamp + "  \n" +
                        "**Detalles**:\n```log\n" + mensajeError.strip() + "\n```\n" +
                        "---\n";
        
        appendToFile("autogen-output/krakens/log-krakens.md", entrada);
        System.out.println("üêô KRAKEN REGISTRADO: " + tipo + " en " + clase);
    }

    /**
     * üéØ CLASIFICACI√ìN TURBO DE KRAKENS
     */
    private static String clasificarKraken(String error) {
        String lower = error.toLowerCase();

        if (lower.contains("filenotfound") || lower.contains("no such file") || lower.contains("cannot find")) {
            return "üíÄ FANTASMA DEL C√ìDIGO - Archivo perdido en la niebla";
        }

        if (lower.contains("nullpointer") || lower.contains("illegalstate") || lower.contains("indexoutofbounds")) {
            return "üå™Ô∏è TORMENTA L√ìGICA - Variables rebeldes";
        }

        if (lower.contains("outofmemory") || lower.contains("stackoverflow") || lower.contains("memory")) {
            return "üêâ LEVIAT√ÅN DEL ABISMO - Memoria insuficiente";
        }

        if (lower.contains("timeout") || lower.contains("connection") || lower.contains("network")) {
            return "‚è∞ KRAKEN DEL TIEMPO - Llamadas eternas";
        }

        if (lower.contains("permission") || lower.contains("access denied") || lower.contains("security")) {
            return "üîí GUARDI√ÅN PROHIBIDO - Permisos denegados";
        }

        return "üêô KRAKEN DESCONOCIDO - Misterio por resolver";
    }

    /**
     * üé™ CAPTURA TURBO DE EXCEPCIONES
     */
    public static void atraparKraken(String clase, Exception e) {
        StringWriter sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        registrarKraken(clase, sw.toString());
    }

    /**
     * üìñ LECTURA TURBO CONDICIONAL
     */
    public static String readFileIfExists(String path) {
        try {
            if (!Files.exists(Paths.get(path))) {
                System.out.println("‚ö†Ô∏è  Archivo opcional no encontrado: " + path);
                return "";
            }
            return readFile(path);
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è  Error leyendo archivo opcional: " + path);
            return "";
        }
    }

    /**
     * üÜï EXTRACCI√ìN TURBO DE M√öLTIPLES CLASES
     */
    public static List<String> extraerMultiplesClases(String respuestaLLM) {
        List<String> clases = new ArrayList<>();
        if (respuestaLLM == null || respuestaLLM.isBlank()) return clases;

        try {
            var matcher = PATRON_CODIGO_JAVA.matcher(respuestaLLM);
            while (matcher.find()) {
                String codigo = matcher.group(1).trim();
                if (!codigo.isEmpty()) {
                    clases.add(codigo);
                }
            }
            
            System.out.println("‚ö° " + clases.size() + " CLASES EXTRA√çDAS");
            return clases;
            
        } catch (Exception e) {
            System.err.println("üí• Error extrayendo m√∫ltiples clases: " + e.getMessage());
            return Collections.singletonList(respuestaLLM.trim());
        }
    }

    /**
     * üìä ESTAD√çSTICAS TURBO FILEUTILS
     */
    public static void mostrarEstadisticasEpicas() {
        System.out.println("\nüìä ESTAD√çSTICAS TURBO FILEUTILS:");
        System.out.println("üìñ Lecturas: " + CONTADOR_LECTURAS.get());
        System.out.println("üìù Escrituras: " + CONTADOR_ESCRITURAS.get());
        System.out.println("üêô Krakens: " + CONTADOR_KRAKENS.get());
        System.out.println("üéØ Cache hits: " + CONTADOR_CACHE_HITS.get());
        System.out.println("üíæ Cache size: " + CACHE_LECTURAS.size());
        System.out.println("üéØ Tasa de cache: " + 
            String.format("%.1f%%", (double)CONTADOR_CACHE_HITS.get() / CONTADOR_LECTURAS.get() * 100));
        System.out.println("‚ö° Eficiencia: " + 
            String.format("%.1f%%", (1 - (double)CONTADOR_KRAKENS.get() / (CONTADOR_LECTURAS.get() + CONTADOR_ESCRITURAS.get())) * 100));
    }

    /**
     * üßπ LIMPIAR CACHE TURBO
     */
    public static void limpiarCache() {
        int tama√±o = CACHE_LECTURAS.size();
        CACHE_LECTURAS.clear();
        CACHE_TIMESTAMPS.clear();
        System.out.println("üóëÔ∏è  CACHE TURBO LIMPIADO: " + tama√±o + " entradas");
    }

    /**
     * üÜï BACKUP TURBO DE ARCHIVO
     */
    public static void crearBackupTurbo(String archivoOriginal) {
        try {
            if (!Files.exists(Paths.get(archivoOriginal))) {
                System.out.println("‚ö†Ô∏è  Archivo no existe para backup: " + archivoOriginal);
                return;
            }
            
            String backupPath = archivoOriginal + ".bak";
            Files.copy(Paths.get(archivoOriginal), Paths.get(backupPath), StandardCopyOption.REPLACE_EXISTING);
            System.out.println("üíæ BACKUP TURBO CREADO: " + backupPath);
            
        } catch (Exception e) {
            System.err.println("üí• Error creando backup: " + archivoOriginal);
        }
    }

    /**
     * üÜï VERIFICACI√ìN TURBO DE ARCHIVO
     */
    public static boolean verificarArchivo(String path) {
        try {
            Path filePath = Paths.get(path);
            return Files.exists(filePath) && 
                   Files.isReadable(filePath) && 
                   Files.isWritable(filePath) &&
                   Files.size(filePath) > 0;
        } catch (Exception e) {
            return false;
        }
    }

	public static void limpiarArchivosTemporales() {
		// TODO Auto-generated method stub
		
	}
	public static String extraerBloqueDeCodigo(String respuesta) {
	    if (respuesta == null || respuesta.trim().isEmpty()) {
	        return "// ‚ùå Respuesta vac√≠a del servidor";
	    }
	    
	    System.out.println("üîç Analizando respuesta: " + respuesta.length() + " chars");
	    
	    // üéØ PATR√ìN 1: Bloques ```java ``` (PREFERIDO)
	    Pattern bloquePattern = Pattern.compile("```(?:java)?\\s*(.*?)\\s*```", Pattern.DOTALL);
	    Matcher bloqueMatcher = bloquePattern.matcher(respuesta);
	    
	    if (bloqueMatcher.find()) {
	        String codigo = bloqueMatcher.group(1).trim();
	        System.out.println("üéØ BLOQUE JAVA EXTRA√çDO: " + codigo.length() + " chars");
	        
	        if (esCodigoJavaValido(codigo)) {
	            return codigo;
	        } else {
	            System.out.println("‚ö†Ô∏è Bloque extra√≠do pero no es v√°lido, buscando alternativas...");
	        }
	    }
	    
	    // üéØ PATR√ìN 2: Buscar c√≥digo Java completo manualmente
	    String codigoCandidato = buscarCodigoJavaCompleto(respuesta);
	    if (esCodigoJavaValido(codigoCandidato)) {
	        System.out.println("üéØ C√ìDIGO JAVA ENCONTRADO: " + codigoCandidato.length() + " chars");
	        return codigoCandidato;
	    }
	    
	    // üéØ √öLTIMO RECURSO: Si parece c√≥digo, intentar repararlo
	    if (respuesta.contains("class ") && respuesta.contains("{")) {
	        String codigoReparado = intentarRepararCodigo(respuesta);
	        if (esCodigoJavaValido(codigoReparado)) {
	            System.out.println("üéØ C√ìDIGO REPARADO: " + codigoReparado.length() + " chars");
	            return codigoReparado;
	        }
	    }
	    
	    System.out.println("‚ùå No se pudo extraer c√≥digo Java v√°lido");
	    return "// ‚ùå ERROR: No se gener√≥ c√≥digo Java v√°lido\n// La respuesta fue: " + 
	           (respuesta.length() > 300 ? respuesta.substring(0, 300) + "..." : respuesta);
	}

	private static String buscarCodigoJavaCompleto(String texto) {
	    // Buscar desde package/import hasta el final
	    int start = 0;
	    if (texto.contains("package ")) start = texto.indexOf("package ");
	    else if (texto.contains("import ")) start = texto.indexOf("import ");
	    else if (texto.contains("public class")) start = texto.indexOf("public class");
	    else if (texto.contains("class ")) start = texto.indexOf("class ");
	    else return texto; // Devolver todo como √∫ltimo recurso
	    
	    return texto.substring(start).trim();
	}

	private static String intentarRepararCodigo(String codigoRoto) {
	    // üéØ Intentar reparar c√≥digo incompleto
	    String reparado = codigoRoto.trim();
	    
	    // Asegurar que termina con }
	    if (!reparado.endsWith("}")) {
	        reparado += "\n}";
	    }
	    
	    // Asegurar que tiene package si parece una clase completa
	    if (reparado.contains("public class") && !reparado.contains("package ")) {
	        // Buscar el nombre de la clase para crear un package dummy
	        Pattern classPattern = Pattern.compile("public class (\\w+)");
	        Matcher matcher = classPattern.matcher(reparado);
	        if (matcher.find()) {
	            String className = matcher.group(1);
	            reparado = "package com.novelator.autogen.util;\n\n" + reparado;
	        }
	    }
	    
	    return reparado;
	}
	
	public static boolean esCodigoJavaValido(String codigo) {
	    if (codigo == null || codigo.trim().isEmpty()) return false;
	    
	    // üéØ Validaciones b√°sicas de c√≥digo Java
	    boolean tienePackage = codigo.contains("package ");
	    boolean tieneClass = codigo.contains(" class ") || codigo.contains("public class");
	    boolean tieneLlaveApertura = codigo.contains("{");
	    boolean tieneLlaveCierre = codigo.contains("}");
	    boolean longitudMinima = codigo.length() > 100;
	    
	    // Debe tener al menos class y llaves
	    boolean esValido = tieneClass && tieneLlaveApertura && tieneLlaveCierre && longitudMinima;
	    
	    if (!esValido) {
	        System.out.println("‚ùå C√≥digo inv√°lido - Faltan: " +
	                         (tieneClass ? "" : "class ") +
	                         (tieneLlaveApertura ? "" : "{ ") +
	                         (tieneLlaveCierre ? "" : "} "));
	    }
	    
	    return esValido;
	}
	
	public static void buscarFormatosInvalidos(String codigo) {
	    // Buscar patrones %V en el c√≥digo
	    if (codigo.contains("%V") || codigo.contains("%v")) {
	        System.err.println("‚ùå FORMATO INV√ÅLIDO ENCONTRADO: %V");
	        System.err.println("üîç Contexto: " + 
	            codigo.substring(Math.max(0, codigo.indexOf("%V") - 50), 
	                           Math.min(codigo.length(), codigo.indexOf("%V") + 50)));
	    }
	}
	
	
}
