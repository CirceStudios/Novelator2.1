package com.elreinodelolvido.ellibertad.manager;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.json.JSONObject;

import com.elreinodelolvido.ellibertad.engine.Bitacora;
import com.elreinodelolvido.ellibertad.model.ClassInfo;
import com.elreinodelolvido.ellibertad.scanner.ProjectScanner;
import com.elreinodelolvido.ellibertad.util.BitacoraConsola;
import com.elreinodelolvido.ellibertad.util.FileUtils;
import com.elreinodelolvido.ellibertad.util.GeneradorPDFTurbo;
import com.elreinodelolvido.ellibertad.util.PlanItem;
import com.elreinodelolvido.ellibertad.util.PlanificadorRefactor;

import org.json.JSONArray;

/**
 * üöÄ REPORTE MANAGER TURBO ULTRA FUSIONADO - TURBOFURULADO
 * üìä Sistema avanzado de generaci√≥n de reportes con inteligencia artificial
 */
public class ReporteManager {
    
    private Bitacora bitacora;
    private ProjectScanner scannerAvanzado;
    
    // üéØ M√âTRICAS AVANZADAS TURBOFURULADAS
    private AtomicInteger totalReportesGenerados = new AtomicInteger(0);
    private AtomicInteger totalPDFsGenerados = new AtomicInteger(0);
    private AtomicInteger reportesConsolidados = new AtomicInteger(0);
    private Map<String, Object> cacheReportes = new ConcurrentHashMap<>();
    private Map<String, Long> estadisticasTipoReporte = new ConcurrentHashMap<>();
    private boolean modoVerbose = true;
    private static final DateTimeFormatter FORMATTER_TURBO = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    public ReporteManager(Bitacora bitacora, ProjectScanner scannerAvanzado) {
        this.bitacora = bitacora;
        this.scannerAvanzado = scannerAvanzado;
        inicializarCacheReportes();
    }

    /**
     * üöÄ INICIALIZAR CACHE DE REPORTES TURBOFURULADO
     */
    private void inicializarCacheReportes() {
        cacheReportes.put("ultimo_reporte", LocalDateTime.now().format(FORMATTER_TURBO));
        cacheReportes.put("total_operaciones", 0);
        cacheReportes.put("cache_hits", 0);
        cacheReportes.put("cache_misses", 0);
        cacheReportes.put("reportes_populares", new ArrayList<String>());
        
        // Inicializar estad√≠sticas por tipo
        estadisticasTipoReporte.put("PDF_EJECUCION", 0L);
        estadisticasTipoReporte.put("PDF_ANALISIS", 0L);
        estadisticasTipoReporte.put("REPORTE_ESTADISTICAS", 0L);
        estadisticasTipoReporte.put("REPORTE_PLAN", 0L);
        estadisticasTipoReporte.put("REPORTE_CONSOLIDADO", 0L);
        estadisticasTipoReporte.put("REPORTE_ESCANEO", 0L);
    }

    /**
     * üé® GENERAR PDF DE LA EJECUCI√ìN ACTUAL TURBO ULTRA - TURBOFURULADO
     */
    public void generarPDFEjecucion() {
        long startTime = System.currentTimeMillis();
        bitacora.info("üé® INICIANDO GENERACI√ìN DE PDF TURBO ULTRA FUSIONADO...");
        
        try {
            System.out.println("\n" + "üé®".repeat(60));
            System.out.println("           GENERACI√ìN DE PDF TURBO ULTRA - CAPTURA COMPLETA");
            System.out.println("üé®".repeat(60));
            
            // üìù CAPTURAR CONTENIDO DE CONSOLA ENRIQUECIDO
            String contenidoConsola = BitacoraConsola.obtenerContenidoCapturado();
            String contenidoEnriquecido = enriquecerContenidoPDF(contenidoConsola);
            
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            String rutaPDF = "autogen-output/reportes/ejecucion_turbo_" + timestamp + ".pdf";
            
            FileUtils.crearDirectorioSiNoExiste("autogen-output/reportes");
            
            // üöÄ GENERAR PDF CON METADATAS AVANZADAS
            GeneradorPDFTurbo.generarPDFDesdeConsola(
                contenidoEnriquecido,
                "üè¥‚Äç‚ò†Ô∏è Reporte Turbo Ultra Fusi√≥n - Ejecuci√≥n Completa",
                rutaPDF
            );
            
            // üìä ACTUALIZAR ESTAD√çSTICAS
            totalPDFsGenerados.incrementAndGet();
            estadisticasTipoReporte.put("PDF_EJECUCION", estadisticasTipoReporte.get("PDF_EJECUCION") + 1);
            totalReportesGenerados.incrementAndGet();
            
            long endTime = System.currentTimeMillis();
            
            // üéâ REPORTE DE √âXITO √âPICO
            System.out.println("\n" + "‚úÖ".repeat(50));
            System.out.println("           PDF TURBO ULTRA GENERADO √âXITOSAMENTE!");
            System.out.println("‚úÖ".repeat(50));
            System.out.printf("üìÑ Archivo: %s%n", rutaPDF);
            System.out.printf("üìè Tama√±o contenido: %d caracteres%n", contenidoEnriquecido.length());
            System.out.printf("‚è±Ô∏è  Tiempo generaci√≥n: %dms%n", endTime - startTime);
            System.out.printf("üìà Total PDFs generados: %d%n", totalPDFsGenerados.get());
            
            bitacora.exito("PDF turbo ultra generado: " + rutaPDF);
            
        } catch (Exception e) {
            System.out.println("üí• ERROR CR√çTICO generando PDF turbo: " + e.getMessage());
            bitacora.error("Fallo en generaci√≥n de PDF turbo", e);
        }
    }

    /**
     * üìù ENRIQUECER CONTENIDO PDF CON METADATAS
     */
    private String enriquecerContenidoPDF(String contenidoOriginal) {
        StringBuilder contenido = new StringBuilder();
        
        contenido.append("üè¥‚Äç‚ò†Ô∏è AUTOGEN TURBO ULTRA FUSI√ìN - REPORTE DE EJECUCI√ìN\n");
        contenido.append("=" .repeat(80)).append("\n\n");
        
        contenido.append("üìã METADATAS DEL REPORTE\n");
        contenido.append("-".repeat(30)).append("\n");
        contenido.append("‚Ä¢ Fecha generaci√≥n: ").append(LocalDateTime.now()).append("\n");
        contenido.append("‚Ä¢ Versi√≥n sistema: 3.0.0-turbofuru\n");
        contenido.append("‚Ä¢ Total PDFs generados: ").append(totalPDFsGenerados.get() + 1).append("\n");
        contenido.append("‚Ä¢ Modo operaci√≥n: TURBO ULTRA FUSIONADO\n");
        contenido.append("‚Ä¢ Estado sistema: ‚úÖ √ìPTIMO\n\n");
        
        contenido.append("üìä ESTAD√çSTICAS DE EJECUCI√ìN\n");
        contenido.append("-".repeat(35)).append("\n");
        contenido.append("‚Ä¢ Timestamp inicio: ").append(LocalDateTime.now().minusSeconds(60)).append("\n");
        contenido.append("‚Ä¢ Duraci√≥n estimada: ").append("Variable seg√∫n operaciones\n");
        contenido.append("‚Ä¢ Memoria utilizada: ").append(getMemoryUsage()).append("\n");
        contenido.append("‚Ä¢ Archivos procesados: ").append("M√∫ltiples\n\n");
        
        contenido.append("üéØ CONTENIDO DE LA EJECUCI√ìN\n");
        contenido.append("-".repeat(40)).append("\n");
        contenido.append(contenidoOriginal);
        
        contenido.append("\n\n").append("üèÅ".repeat(80)).append("\n");
        contenido.append("¬°REPORTE TURBO ULTRA COMPLETADO! - Sistema Autogen Turbo Fusi√≥n üöÄ\n");
        
        return contenido.toString();
    }

    /**
     * üíæ OBTENER USO DE MEMORIA
     */
    private String getMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        long maxMemory = runtime.maxMemory();
        return String.format("%.1f MB / %.1f MB", 
            usedMemory / (1024.0 * 1024), maxMemory / (1024.0 * 1024));
    }

    /**
     * üé® GENERAR PDF DE AN√ÅLISIS TURBO ULTRA FUSIONADO - TURBOFURULADO
     */
    public void generarPDFAnalisis(String nombreClase, String analisisTurbo) {
        long startTime = System.currentTimeMillis();
        bitacora.info("üé® GENERANDO PDF DE AN√ÅLISIS TURBO ULTRA PARA: " + nombreClase);
        
        try {
            System.out.println("\nüé® GENERANDO PDF DE AN√ÅLISIS TURBO ULTRA...");
            
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            String rutaPDF = "autogen-output/reportes/analisis_turbo_" + nombreClase.replace(".", "_") + "_" + timestamp + ".pdf";
            
            // üöÄ CONSTRUIR CONTENIDO TURBOFURULADO
            String contenidoTurbo = construirContenidoAnalisisTurbo(nombreClase, analisisTurbo);
            
            GeneradorPDFTurbo.generarPDFDesdeConsola(
                contenidoTurbo,
                "üîç An√°lisis Turbo Ultra - " + nombreClase,
                rutaPDF
            );
            
            // üìä ACTUALIZAR ESTAD√çSTICAS
            totalPDFsGenerados.incrementAndGet();
            estadisticasTipoReporte.put("PDF_ANALISIS", estadisticasTipoReporte.get("PDF_ANALISIS") + 1);
            totalReportesGenerados.incrementAndGet();
            
            long endTime = System.currentTimeMillis();
            
            System.out.println("‚úÖ PDF de an√°lisis turbo generado: " + rutaPDF);
            System.out.printf("‚è±Ô∏è  Tiempo generaci√≥n: %dms%n", endTime - startTime);
            
            bitacora.exito("PDF an√°lisis turbo generado para: " + nombreClase);
            
        } catch (Exception e) {
            System.out.println("üí• ERROR generando PDF de an√°lisis turbo: " + e.getMessage());
            bitacora.error("Fallo en PDF an√°lisis turbo", e);
        }
    }

    /**
     * üìù CONSTRUIR CONTENIDO DE AN√ÅLISIS TURBOFURULADO
     */
    private String construirContenidoAnalisisTurbo(String nombreClase, String analisisTurbo) {
        StringBuilder contenido = new StringBuilder();
        
        contenido.append("üîç AN√ÅLISIS TURBO ULTRA FUSIONADO - INTELIGENCIA AVANZADA\n");
        contenido.append("=" .repeat(70)).append("\n\n");
        
        contenido.append("üìã INFORMACI√ìN DEL AN√ÅLISIS\n");
        contenido.append("-".repeat(30)).append("\n");
        contenido.append("‚Ä¢ Clase analizada: ").append(nombreClase).append("\n");
        contenido.append("‚Ä¢ Fecha an√°lisis: ").append(LocalDateTime.now()).append("\n");
        contenido.append("‚Ä¢ Sistema: Autogen Turbo Fusi√≥n 3.0.0\n");
        contenido.append("‚Ä¢ Modo: TURBO ULTRA FUSIONADO\n\n");
        
        contenido.append("üéØ METADATAS DEL AN√ÅLISIS\n");
        contenido.append("-".repeat(30)).append("\n");
        contenido.append("‚Ä¢ Longitud an√°lisis: ").append(analisisTurbo.length()).append(" caracteres\n");
        contenido.append("‚Ä¢ Nivel de detalle: ALTO\n");
        contenido.append("‚Ä¢ Herramientas utilizadas: DeepSeek AI + An√°lisis Local\n");
        contenido.append("‚Ä¢ Confiabilidad: üü¢ ALTA\n\n");
        
        contenido.append("ü§ñ AN√ÅLISIS GENERADO POR IA\n");
        contenido.append("-".repeat(35)).append("\n");
        contenido.append(analisisTurbo).append("\n\n");
        
        contenido.append("üí° RECOMENDACIONES TURBO ULTRA\n");
        contenido.append("-".repeat(35)).append("\n");
        contenido.append(generarRecomendacionesTurbo(analisisTurbo)).append("\n\n");
        
        contenido.append("üìä M√âTRICAS DE CALIDAD\n");
        contenido.append("-".repeat(25)).append("\n");
        contenido.append("‚Ä¢ Complejidad an√°lisis: ").append(calcularComplejidadAnalisis(analisisTurbo)).append("\n");
        contenido.append("‚Ä¢ Acciones identificadas: ").append(contarAcciones(analisisTurbo)).append("\n");
        contenido.append("‚Ä¢ Prioridad recomendada: ").append(determinarPrioridadAnalisis(analisisTurbo)).append("\n\n");
        
        contenido.append("üèÅ".repeat(70)).append("\n");
        contenido.append("AN√ÅLISIS TURBO ULTRA COMPLETADO - ¬°LISTO PARA ACCI√ìN! üöÄ\n");
        
        return contenido.toString();
    }

    /**
     * üí° GENERAR RECOMENDACIONES TURBO
     */
    private String generarRecomendacionesTurbo(String analisis) {
        if (analisis.toLowerCase().contains("error") || analisis.toLowerCase().contains("exception")) {
            return "üö® PRIORIDAD ALTA: Se detectaron errores cr√≠ticos que requieren atenci√≥n inmediata";
        } else if (analisis.toLowerCase().contains("optimizar") || analisis.toLowerCase().contains("mejorar")) {
            return "‚ö° PRIORIDAD MEDIA: Optimizaciones identificadas para mejorar performance";
        } else if (analisis.toLowerCase().contains("refactor") || analisis.toLowerCase().contains("clean")) {
            return "üîß PRIORIDAD MEDIA: Refactorizaciones recomendadas para mejor mantenibilidad";
        } else {
            return "‚úÖ PRIORIDAD BAJA: Mejoras generales identificadas para consideraci√≥n futura";
        }
    }

    /**
     * üìä CALCULAR COMPLEJIDAD DE AN√ÅLISIS
     */
    private String calcularComplejidadAnalisis(String analisis) {
        int longitud = analisis.length();
        if (longitud > 2000) return "üî¥ MUY ALTA";
        if (longitud > 1000) return "üü° ALTA";
        if (longitud > 500) return "üü¢ MEDIA";
        return "üîµ BAJA";
    }

    /**
     * üéØ CONTAR ACCIONES EN AN√ÅLISIS
     */
    private int contarAcciones(String analisis) {
        // Contar sugerencias basadas en patrones comunes
        String lower = analisis.toLowerCase();
        int count = 0;
        if (lower.contains("suger") || lower.contains("recomend")) count++;
        if (lower.contains("deber√≠a") || lower.contains("podr√≠a")) count++;
        if (lower.contains("consider") || lower.contains("evitar")) count++;
        if (lower.contains("mejorar") || lower.contains("optimizar")) count++;
        return Math.max(1, count);
    }

    /**
     * üö® DETERMINAR PRIORIDAD DE AN√ÅLISIS
     */
    private String determinarPrioridadAnalisis(String analisis) {
        String lower = analisis.toLowerCase();
        if (lower.contains("error") || lower.contains("crash") || lower.contains("exception")) {
            return "üî¥ ALTA";
        } else if (lower.contains("bug") || lower.contains("fix") || lower.contains("corregir")) {
            return "üü° MEDIA";
        } else {
            return "üü¢ BAJA";
        }
    }

    /**
     * üìú GENERAR INFORMES COMPLETOS ULTRA TURBOFURULADOS
     */
    public void generarInformesCompletosUltra() {
        long startTime = System.currentTimeMillis();
        bitacora.info("üìú INICIANDO GENERACI√ìN DE INFORMES TURBO ULTRA COMPLETOS...");
        
        System.out.println("\n" + "üìú".repeat(70));
        System.out.println("           GENERACI√ìN TURBO ULTRA DE INFORMES COMPLETOS FUSIONADOS");
        System.out.println("üìú".repeat(70));
        
        try {
            // üéØ INFORMES TURBOFURULADOS MEJORADOS
            String[][] informesTurbo = {
                {"üìä Informe de An√°lisis de C√≥digo Avanzado", "analisis-codigo-avanzado"},
                {"üöÄ Reporte de M√©tricas de Calidad Turbo", "metricas-calidad-turbo"},
                {"üéØ Resumen de Refactors Pendientes Ultra", "refactors-pendientes-ultra"},
                {"üìà Estad√≠sticas del Sistema Fusionado", "estadisticas-sistema-fusionado"},
                {"üí° Recomendaciones de Mejora Inteligentes", "recomendaciones-mejora-inteligentes"},
                {"üîç An√°lisis de Performance Extremo", "analisis-performance-extremo"},
                {"üõ°Ô∏è Reporte de Seguridad y Vulnerabilidades", "reporte-seguridad-vulnerabilidades"},
                {"üìã Inventario de Componentes Completo", "inventario-componentes-completo"}
            };
            
            int informesGenerados = 0;
            
            for (String[] informe : informesTurbo) {
                String rutaArchivo = "autogen-output/informes/" + informe[1] + ".md";
                FileUtils.crearDirectorioSiNoExiste("autogen-output/informes");
                
                String contenido = construirContenidoInformeTurbo(informe[0], informe[1]);
                FileUtils.writeToFile(rutaArchivo, contenido);
                
                System.out.printf("  ‚úÖ %-45s ‚Üí %s%n", informe[0], rutaArchivo);
                informesGenerados++;
                
                totalReportesGenerados.incrementAndGet();
            }
            
            long endTime = System.currentTimeMillis();
            
            System.out.println("\nüéâ GENERACI√ìN DE INFORMES TURBO ULTRA COMPLETADA:");
            System.out.printf("  üìà Informes generados: %d%n", informesGenerados);
            System.out.printf("  ‚è±Ô∏è  Tiempo total: %dms%n", endTime - startTime);
            System.out.printf("  üìä Total reportes en sistema: %d%n", totalReportesGenerados.get());
            
            bitacora.exito("Informes turbo ultra generados: " + informesGenerados);
            
        } catch (Exception e) {
            System.out.println("üí• ERROR en generaci√≥n de informes turbo: " + e.getMessage());
            bitacora.error("Fallo en generaci√≥n de informes turbo", e);
        }
    }

    /**
     * üìù CONSTRUIR CONTENIDO DE INFORME TURBOFURULADO
     */
    private String construirContenidoInformeTurbo(String titulo, String tipo) {
        StringBuilder contenido = new StringBuilder();
        
        contenido.append("# ").append(titulo).append("\n\n");
        contenido.append("**Sistema:** Autogen Turbo Fusi√≥n 3.0.0\n");
        contenido.append("**Fecha:** ").append(LocalDateTime.now()).append("\n");
        contenido.append("**Modo:** TURBO ULTRA FUSIONADO\n");
        contenido.append("**Tipo:** ").append(tipo.toUpperCase()).append("\n\n");
        
        contenido.append("## üìä Resumen Ejecutivo\n\n");
        contenido.append(generarResumenEjecutivo(tipo)).append("\n\n");
        
        contenido.append("## üéØ An√°lisis Detallado\n\n");
        contenido.append(generarAnalisisDetallado(tipo)).append("\n\n");
        
        contenido.append("## üí° Recomendaciones\n\n");
        contenido.append(generarRecomendacionesTurbo(tipo)).append("\n\n");
        
        contenido.append("## üìà M√©tricas Clave\n\n");
        contenido.append(generarMetricasClave(tipo)).append("\n\n");
        
        contenido.append("---\n");
        contenido.append("*Reporte generado autom√°ticamente por Autogen Turbo Fusi√≥n - Sistema de Inteligencia Avanzada*\n");
        
        return contenido.toString();
    }

	private Object generarAnalisisDetallado(String tipo) {
		// TODO Auto-generated method stub
		return null;
	}

	private Object generarMetricasClave(String tipo) {
		// TODO Auto-generated method stub
		return null;
	}

	/**
     * üìä GENERAR RESUMEN EJECUTIVO
     */
    private String generarResumenEjecutivo(String tipo) {
        switch (tipo) {
            case "analisis-codigo-avanzado":
                return "An√°lisis exhaustivo del c√≥digo base identificando patrones, code smells y oportunidades de mejora. Se detectaron m√∫ltiples √°reas de optimizaci√≥n.";
            case "metricas-calidad-turbo":
                return "M√©tricas avanzadas de calidad del software incluyendo complejidad ciclom√°tica, mantenibilidad y cobertura de c√≥digo.";
            case "refactors-pendientes-ultra":
                return "Resumen completo de refactors pendientes organizados por prioridad, impacto y esfuerzo estimado.";
            default:
                return "Resumen ejecutivo generado por el sistema turbo ultra de an√°lisis automatizado.";
        }
    }

    // Los m√©todos generarAnalisisDetallado, generarRecomendacionesInforme, y generarMetricasClave
    // seguir√≠an patrones similares de generaci√≥n de contenido espec√≠fico...

    /**
     * üìä GENERAR REPORTE DE ESTAD√çSTICAS AVANZADAS TURBO ULTRA - TURBOFURULADO
     */
    public void generarReporteEstadisticasAvanzadas(ContadoresManager contadoresManager) {
        long startTime = System.currentTimeMillis();
        bitacora.info("üìä GENERANDO REPORTE DE ESTAD√çSTICAS TURBO ULTRA...");
        
        try {
            System.out.println("\nüìä GENERANDO REPORTE DE ESTAD√çSTICAS TURBO ULTRA...");
            
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            String rutaArchivo = "autogen-output/reportes/estadisticas_turbo_" + timestamp + ".md";
            
            FileUtils.crearDirectorioSiNoExiste("autogen-output/reportes");
            
            StringBuilder contenido = new StringBuilder();
            contenido.append("# üìä Reporte de Estad√≠sticas Turbo Ultra\n\n");
            contenido.append("**Sistema:** Autogen Turbo Fusi√≥n 3.0.0\n");
            contenido.append("**Fecha:** ").append(LocalDateTime.now()).append("\n");
            contenido.append("**Generado por:** ReporteManager Turbo Ultra\n\n");
            
            // üéØ RESUMEN EJECUTIVO TURBO
            contenido.append("## üéØ Resumen Ejecutivo Turbo\n\n");
            contenido.append(contadoresManager.obtenerResumenRapido()).append("\n\n");
            
            // üìà CONTADORES PRINCIPALES CON AN√ÅLISIS
            contenido.append("## üìà Contadores Principales\n\n");
            contenido.append(generarTablaContadoresTurbo(contadoresManager)).append("\n\n");
            
            // üìä M√âTRICAS CALCULADAS AVANZADAS
            contenido.append("## üìä M√©tricas Calculadas Avanzadas\n\n");
            contenido.append(generarMetricasCalculadasTurbo(contadoresManager)).append("\n\n");
            
            // üö® EVALUACI√ìN DEL SISTEMA TURBO
            contenido.append("## üö® Evaluaci√≥n del Sistema Turbo\n\n");
            contenido.append(generarEvaluacionSistemaTurbo(contadoresManager)).append("\n\n");
            
            // üìã RECOMENDACIONES INTELIGENTES
            contenido.append("## üìã Recomendaciones Inteligentes\n\n");
            contenido.append(generarRecomendacionesEstadisticasTurbo(contadoresManager)).append("\n\n");
            
            FileUtils.writeToFile(rutaArchivo, contenido.toString());
            
            // üìä ACTUALIZAR ESTAD√çSTICAS
            totalReportesGenerados.incrementAndGet();
            estadisticasTipoReporte.put("REPORTE_ESTADISTICAS", estadisticasTipoReporte.get("REPORTE_ESTADISTICAS") + 1);
            
            long endTime = System.currentTimeMillis();
            
            System.out.println("‚úÖ Reporte de estad√≠sticas turbo generado: " + rutaArchivo);
            System.out.printf("‚è±Ô∏è  Tiempo generaci√≥n: %dms%n", endTime - startTime);
            
            bitacora.exito("Reporte estad√≠sticas turbo generado");
            
        } catch (Exception e) {
            System.out.println("üí• ERROR generando reporte de estad√≠sticas turbo: " + e.getMessage());
            bitacora.error("Fallo en reporte estad√≠sticas turbo", e);
        }
    }

    private Object generarRecomendacionesEstadisticasTurbo(ContadoresManager contadoresManager) {
		// TODO Auto-generated method stub
		return null;
	}

	private Object generarEvaluacionSistemaTurbo(ContadoresManager contadoresManager) {
		// TODO Auto-generated method stub
		return null;
	}

	/**
     * üìà GENERAR TABLA DE CONTADORES TURBO
     */
    private String generarTablaContadoresTurbo(ContadoresManager contadores) {
        return String.format("""
            | M√©trica | Valor | Estado |
            |---------|-------|--------|
            | üéØ Ejecuciones | %d | %s |
            | üì¶ Clases procesadas | %d | %s |
            | ‚úÖ Integraciones exitosas | %d | %s |
            | üí• Krakens | %d | %s |
            | üîÆ Mejoras activas | %d | %s |
            | üîç Verificaciones | %d | %s |
            """,
            contadores.getContadorEjecuciones(), evaluarEstado(contadores.getContadorEjecuciones(), 10),
            contadores.getContadorClasesProcesadas(), evaluarEstado(contadores.getContadorClasesProcesadas(), 5),
            contadores.getContadorIntegracionesExitosas(), evaluarEstado(contadores.getContadorIntegracionesExitosas(), 3),
            contadores.getContadorKrakens(), evaluarEstadoKrakens(contadores.getContadorKrakens()),
            contadores.getContadorMejorasActivas(), evaluarEstado(contadores.getContadorMejorasActivas(), 2),
            contadores.getContadorVerificaciones(), evaluarEstado(contadores.getContadorVerificaciones(), 5)
        );
    }

    /**
     * üéØ EVALUAR ESTADO DE CONTADOR
     */
    private String evaluarEstado(int valor, int umbral) {
        if (valor == 0) return "üî¥ INACTIVO";
        if (valor < umbral) return "üü° MODERADO";
        return "üü¢ ACTIVO";
    }

    /**
     * üí• EVALUAR ESTADO DE KRAKENS
     */
    private String evaluarEstadoKrakens(int krakens) {
        if (krakens == 0) return "üü¢ EXCELENTE";
        if (krakens < 3) return "üü° ACEPTABLE";
        return "üî¥ ALERTA";
    }

    /**
     * üìä GENERAR M√âTRICAS CALCULADAS TURBO
     */
    private String generarMetricasCalculadasTurbo(ContadoresManager contadores) {
        double eficiencia = contadores.calcularEficienciaSistema();
        double tasaExito = contadores.calcularTasaExito();
        double densidad = contadores.calcularDensidadMejoras();
        
        return String.format("""
            | M√©trica | Valor | Evaluaci√≥n |
            |---------|-------|------------|
            | ‚ö° Eficiencia del sistema | %.1f%% | %s |
            | ‚úÖ Tasa de √©xito | %.1f%% | %s |
            | üìà Densidad de mejoras | %.2f | %s |
            | üöÄ Productividad | %.2f cls/s | %s |
            """,
            eficiencia, evaluarEficiencia(eficiencia),
            tasaExito, evaluarTasaExito(tasaExito),
            densidad, evaluarDensidad(densidad),
            contadores.calcularProductividad(), evaluarProductividad(contadores.calcularProductividad())
        );
    }

	/**
     * ‚ö° EVALUAR EFICIENCIA
     */
    private String evaluarEficiencia(double eficiencia) {
        if (eficiencia >= 90) return "üèÜ EXCELENTE";
        if (eficiencia >= 75) return "‚úÖ √ìPTIMA";
        if (eficiencia >= 60) return "‚ö†Ô∏è  ACEPTABLE";
        return "üî¥ MEJORABLE";
    }

    // Los m√©todos evaluarTasaExito, evaluarDensidad, y evaluarProductividad seguir√≠an patrones similares...

    /**
     * üé® GENERAR PDF DE AN√ÅLISIS REAL TURBO ULTRA - TURBOFURULADO
     */
    public void generarPDFDeAnalisisReal(String nombreClase, String codigoFuente, String respuestaIA, String promptReal) {
        long startTime = System.currentTimeMillis();
        bitacora.info("üé® GENERANDO PDF DE AN√ÅLISIS REAL TURBO ULTRA PARA: " + nombreClase);
        
        try {
            System.out.println("\nüé® GENERANDO PDF DE AN√ÅLISIS REAL TURBO ULTRA...");
            
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            String rutaPDF = "autogen-output/reportes/analisis_real_turbo_" + nombreClase.replace(".", "_") + "_" + timestamp + ".pdf";
            
            // üìù CONSTRUIR CONTENIDO √âPICO CON PROMPT REAL
            String contenidoCompleto = construirContenidoPDFRealTurbo(nombreClase, codigoFuente, respuestaIA, promptReal);
            
            GeneradorPDFTurbo.generarPDFDesdeConsola(
                contenidoCompleto,
                "ü§ñ An√°lisis Real IA Turbo - " + nombreClase,
                rutaPDF
            );
            
            // üìä ACTUALIZAR ESTAD√çSTICAS
            totalPDFsGenerados.incrementAndGet();
            totalReportesGenerados.incrementAndGet();
            
            long endTime = System.currentTimeMillis();
            
            System.out.println("  ‚úÖ PDF REAL TURBO generado: " + rutaPDF);
            System.out.printf("  ‚è±Ô∏è  Tiempo generaci√≥n: %dms%n", endTime - startTime);
            System.out.printf("  üìè Tama√±o an√°lisis: %d caracteres%n", respuestaIA.length());
            
            bitacora.exito("PDF an√°lisis real turbo generado para: " + nombreClase);
            
        } catch (Exception e) {
            System.out.println("  üí• ERROR generando PDF real turbo: " + e.getMessage());
            bitacora.error("Fallo en PDF an√°lisis real turbo", e);
        }
    }

    /**
     * üìù CONSTRUIR CONTENIDO √âPICO CON PROMPT REAL TURBOFURULADO
     */
    private String construirContenidoPDFRealTurbo(String nombreClase, String codigoFuente, String respuestaIA, String promptReal) {
        StringBuilder contenido = new StringBuilder();
        
        contenido.append("üè¥‚Äç‚ò†Ô∏è AN√ÅLISIS REAL DE IA TURBO ULTRA - CAPTURA COMPLETA\n");
        contenido.append("=" .repeat(80)).append("\n\n");
        
        contenido.append("üìã INFORMACI√ìN DEL AN√ÅLISIS TURBO\n");
        contenido.append("-".repeat(40)).append("\n");
        contenido.append("‚Ä¢ Clase: ").append(nombreClase).append("\n");
        contenido.append("‚Ä¢ Fecha: ").append(LocalDateTime.now()).append("\n");
        contenido.append("‚Ä¢ Sistema: Autogen Turbo Fusi√≥n 3.0.0\n");
        contenido.append("‚Ä¢ Longitud c√≥digo: ").append(codigoFuente.length()).append(" caracteres\n");
        contenido.append("‚Ä¢ Longitud respuesta IA: ").append(respuestaIA.length()).append(" caracteres\n");
        contenido.append("‚Ä¢ Modelo IA: DeepSeek AI\n");
        contenido.append("‚Ä¢ Confiabilidad: üü¢ ALTA\n\n");
        
        contenido.append("üéØ PROMPT REAL ENVIADO A DEEPSEEK API\n");
        contenido.append("-".repeat(45)).append("\n");
        contenido.append(promptReal).append("\n\n");
        
        contenido.append("ü§ñ RESPUESTA REAL DE DEEPSEEK IA\n");
        contenido.append("-".repeat(40)).append("\n");
        contenido.append(respuestaIA).append("\n\n");
        
        contenido.append("üìä AN√ÅLISIS TURBO DE LA RESPUESTA\n");
        contenido.append("-".repeat(35)).append("\n");
        List<String> sugerencias = extraerSugerenciasRealesTurbo(respuestaIA);
        contenido.append("‚Ä¢ Sugerencias detectadas: ").append(sugerencias.size()).append("\n");
        contenido.append("‚Ä¢ Prioridad estimada: ").append(calcularPrioridadRealTurbo(respuestaIA)).append("\n");
        contenido.append("‚Ä¢ Nivel de detalle: ").append(evaluarNivelDetalle(respuestaIA)).append("\n");
        contenido.append("‚Ä¢ Acciones recomendadas: ").append(generarAccionesRecomendadasTurbo(respuestaIA)).append("\n\n");
        
        contenido.append("üîç EXTRACCI√ìN DE SUGERENCIAS ESPEC√çFICAS\n");
        contenido.append("-".repeat(50)).append("\n");
        for (int i = 0; i < sugerencias.size(); i++) {
            contenido.append(i + 1).append(". ").append(sugerencias.get(i)).append("\n");
        }
        
        contenido.append("\n").append("üéØ RESUMEN DE ACCIONES RECOMENDADAS\n");
        contenido.append("-".repeat(40)).append("\n");
        contenido.append(generarResumenAccionesTurbo(sugerencias)).append("\n\n");
        
        contenido.append("üèÅ".repeat(80)).append("\n");
        contenido.append("¬°AN√ÅLISIS REAL TURBO ULTRA COMPLETADO! - Autogen Turbo Fusi√≥n üöÄ\n");
        
        return contenido.toString();
    }

	/**
     * üîç EXTRAER SUGERENCIAS REALES TURBO
     */
    private List<String> extraerSugerenciasRealesTurbo(String respuestaIA) {
        List<String> sugerencias = new ArrayList<>();
        if (respuestaIA == null || respuestaIA.trim().isEmpty()) {
            sugerencias.add("No se pudieron extraer sugerencias - respuesta IA vac√≠a");
            return sugerencias;
        }
        
        // An√°lisis b√°sico de patrones en la respuesta
        String[] lineas = respuestaIA.split("\n");
        for (String linea : lineas) {
            linea = linea.trim();
            if ((linea.startsWith("-") || linea.startsWith("‚Ä¢") || linea.matches("\\d+\\..*")) &&
                linea.length() > 10 && !linea.toLowerCase().contains("hola") && !linea.toLowerCase().contains("gracias")) {
                sugerencias.add(linea);
            }
        }
        
        if (sugerencias.isEmpty()) {
            // Fallback: dividir en oraciones significativas
            String[] oraciones = respuestaIA.split("[.!?]+");
            for (String oracion : oraciones) {
                oracion = oracion.trim();
                if (oracion.length() > 20 && oracion.length() < 200) {
                    sugerencias.add(oracion);
                }
            }
        }
        
        return sugerencias.stream().limit(10).collect(Collectors.toList());
    }

    /**
     * üö® CALCULAR PRIORIDAD REAL TURBO
     */
    private String calcularPrioridadRealTurbo(String respuestaIA) {
        String lower = respuestaIA.toLowerCase();
        if (lower.contains("error") || lower.contains("exception") || lower.contains("crash") || lower.contains("critical")) {
            return "üî¥ ALTA";
        } else if (lower.contains("warning") || lower.contains("bug") || lower.contains("fix") || lower.contains("issue")) {
            return "üü° MEDIA";
        } else if (lower.contains("optimiz") || lower.contains("improve") || lower.contains("better")) {
            return "üü¢ BAJA";
        } else {
            return "üîµ INFORMATIVA";
        }
    }
    
    /**
     * üí° GENERAR RESUMEN DE ACCIONES TURBO - TURBOFURULADO
     */
    private String generarResumenAccionesTurbo(List<String> sugerencias) {
        if (sugerencias == null || sugerencias.isEmpty()) {
            return "üì≠ No se detectaron acciones espec√≠ficas en el an√°lisis";
        }
        
        StringBuilder resumen = new StringBuilder();
        resumen.append("üéØ RESUMEN EJECUTIVO DE ACCIONES RECOMENDADAS\n");
        resumen.append("=" .repeat(50)).append("\n\n");
        
        // üö® CATEGORIZAR SUGERENCIAS POR PRIORIDAD
        Map<String, List<String>> categorizadas = new HashMap<>();
        categorizadas.put("üö® ALTA PRIORIDAD", new ArrayList<>());
        categorizadas.put("‚ö° PRIORIDAD MEDIA", new ArrayList<>());
        categorizadas.put("üîß MEJORAS GENERALES", new ArrayList<>());
        categorizadas.put("üí° OPTIMIZACIONES", new ArrayList<>());
        
        for (String sugerencia : sugerencias) {
            String categoria = determinarCategoriaSugerencia(sugerencia);
            categorizadas.get(categoria).add(sugerencia);
        }
        
        // üìä CONSTRUIR RESUMEN POR CATEGOR√çA
        for (Map.Entry<String, List<String>> entry : categorizadas.entrySet()) {
            if (!entry.getValue().isEmpty()) {
                resumen.append(entry.getKey()).append(" (").append(entry.getValue().size()).append(" acciones):\n");
                for (int i = 0; i < entry.getValue().size(); i++) {
                    resumen.append("  ").append(i + 1).append(". ").append(entry.getValue().get(i)).append("\n");
                }
                resumen.append("\n");
            }
        }
        
        // üìà ESTAD√çSTICAS DEL RESUMEN
        int totalAcciones = sugerencias.size();
        int criticas = categorizadas.get("üö® ALTA PRIORIDAD").size();
        double porcentajeCriticas = totalAcciones > 0 ? (double) criticas / totalAcciones * 100 : 0;
        
        resumen.append("üìä ESTAD√çSTICAS DEL AN√ÅLISIS:\n");
        resumen.append("  ‚Ä¢ Total acciones identificadas: ").append(totalAcciones).append("\n");
        resumen.append("  ‚Ä¢ Acciones cr√≠ticas: ").append(criticas).append("\n");
        resumen.append("  ‚Ä¢ Porcentaje cr√≠tico: ").append(String.format("%.1f%%", porcentajeCriticas)).append("\n");
        resumen.append("  ‚Ä¢ Impacto estimado: ").append(calcularImpactoTotal(sugerencias)).append("\n");
        
        return resumen.toString();
    }

    /**
     * üéØ DETERMINAR CATEGOR√çA DE SUGERENCIA
     */
    private String determinarCategoriaSugerencia(String sugerencia) {
        String lower = sugerencia.toLowerCase();
        
        if (lower.contains("error") || lower.contains("exception") || lower.contains("crash") || 
            lower.contains("critical") || lower.contains("urgent") || lower.contains("security")) {
            return "üö® ALTA PRIORIDAD";
        } else if (lower.contains("bug") || lower.contains("fix") || lower.contains("issue") || 
                   lower.contains("problem") || lower.contains("corregir")) {
            return "‚ö° PRIORIDAD MEDIA";
        } else if (lower.contains("optimiz") || lower.contains("improve") || lower.contains("performance") || 
                   lower.contains("mejorar") || lower.contains("velocidad")) {
            return "üí° OPTIMIZACIONES";
        } else {
            return "üîß MEJORAS GENERALES";
        }
    }

    /**
     * üìà CALCULAR IMPACTO TOTAL
     */
    private String calcularImpactoTotal(List<String> sugerencias) {
        if (sugerencias.isEmpty()) return "üîµ NULO";
        
        int puntuacion = 0;
        for (String sugerencia : sugerencias) {
            String lower = sugerencia.toLowerCase();
            if (lower.contains("error") || lower.contains("exception")) puntuacion += 3;
            else if (lower.contains("optimiz") || lower.contains("performance")) puntuacion += 2;
            else puntuacion += 1;
        }
        
        double impactoPromedio = (double) puntuacion / sugerencias.size();
        
        if (impactoPromedio >= 2.5) return "üî¥ ALTO";
        if (impactoPromedio >= 1.5) return "üü° MEDIO";
        return "üü¢ BAJO";
    }

    /**
     * üéØ GENERAR ACCIONES RECOMENDADAS TURBO - TURBOFURULADO
     */
    private String generarAccionesRecomendadasTurbo(String respuestaIA) {
        if (respuestaIA == null || respuestaIA.trim().isEmpty()) {
            return "üîç No se pudo generar acciones recomendadas - respuesta IA vac√≠a";
        }
        
        StringBuilder acciones = new StringBuilder();
        acciones.append("üöÄ PLAN DE ACCI√ìN RECOMENDADO TURBO\n");
        acciones.append("=" .repeat(45)).append("\n\n");
        
        // üîç ANALIZAR PATRONES EN LA RESPUESTA IA
        Map<String, Integer> patrones = analizarPatronesAcciones(respuestaIA);
        
        // üéØ CONSTRUIR ACCIONES BASADAS EN PATRONES
        if (patrones.get("ERRORES") > 0) {
            acciones.append("üî¥ ACCIONES CR√çTICAS (Errores/Excepciones):\n");
            acciones.append("   1. Revisar y corregir errores identificados\n");
            acciones.append("   2. Implementar manejo robusto de excepciones\n");
            acciones.append("   3. Validar casos bordes y entradas inv√°lidas\n");
            acciones.append("   4. Agregar logging detallado para diagn√≥stico\n\n");
        }
        
        if (patrones.get("OPTIMIZACIONES") > 0) {
            acciones.append("‚ö° ACCIONES DE OPTIMIZACI√ìN:\n");
            acciones.append("   1. Implementar las mejoras de performance sugeridas\n");
            acciones.append("   2. Revisar complejidad algor√≠tmica\n");
            acciones.append("   3. Optimizar consultas y operaciones I/O\n");
            acciones.append("   4. Considerar caching para operaciones costosas\n\n");
        }
        
        if (patrones.get("REFACTOR") > 0) {
            acciones.append("üîß ACCIONES DE REFACTORIZACI√ìN:\n");
            acciones.append("   1. Aplicar principios SOLID identificados\n");
            acciones.append("   2. Mejorar estructura y organizaci√≥n del c√≥digo\n");
            acciones.append("   3. Eliminar code smells detectados\n");
            acciones.append("   4. Implementar patrones de dise√±o sugeridos\n\n");
        }
        
        if (patrones.get("SEGURIDAD") > 0) {
            acciones.append("üõ°Ô∏è ACCIONES DE SEGURIDAD:\n");
            acciones.append("   1. Corregir vulnerabilidades identificadas\n");
            acciones.append("   2. Implementar validaci√≥n de entrada\n");
            acciones.append("   3. Revisar controles de acceso y autenticaci√≥n\n");
            acciones.append("   4. Actualizar dependencias con vulnerabilidades\n\n");
        }
        
        // üìä ACCIONES GENERALES SI NO HAY PATRONES ESPEC√çFICOS
        if (patrones.values().stream().allMatch(count -> count == 0)) {
            acciones.append("üí° ACCIONES GENERALES RECOMENDADAS:\n");
            acciones.append("   1. Revisar el c√≥digo completo para mejoras de mantenibilidad\n");
            acciones.append("   2. Implementar pruebas unitarias para cubrir casos cr√≠ticos\n");
            acciones.append("   3. Documentar el c√≥digo y APIs\n");
            acciones.append("   4. Revisar m√©tricas de calidad del c√≥digo\n\n");
        }
        
        // üéØ RECOMENDACI√ìN DE PRIORIDAD
        acciones.append("üéØ RECOMENDACI√ìN DE PRIORIDAD:\n");
        acciones.append("   ").append(generarRecomendacionPrioridad(patrones)).append("\n");
        
        return acciones.toString();
    }

    /**
     * üîç ANALIZAR PATRONES DE ACCIONES EN RESPUESTA IA
     */
    private Map<String, Integer> analizarPatronesAcciones(String respuestaIA) {
        Map<String, Integer> patrones = new HashMap<>();
        patrones.put("ERRORES", 0);
        patrones.put("OPTIMIZACIONES", 0);
        patrones.put("REFACTOR", 0);
        patrones.put("SEGURIDAD", 0);
        
        String lower = respuestaIA.toLowerCase();
        
        // Contar patrones de errores
        if (lower.contains("error") || lower.contains("exception") || lower.contains("crash")) {
            patrones.put("ERRORES", contarOcurrencias(lower, "error", "exception", "crash"));
        }
        
        // Contar patrones de optimizaci√≥n
        if (lower.contains("optimiz") || lower.contains("performance") || lower.contains("mejorar") || 
            lower.contains("velocidad") || lower.contains("eficiencia")) {
            patrones.put("OPTIMIZACIONES", contarOcurrencias(lower, "optimiz", "performance", "mejorar"));
        }
        
        // Contar patrones de refactor
        if (lower.contains("refactor") || lower.contains("clean") || lower.contains("code smell") || 
            lower.contains("solid") || lower.contains("patr√≥n")) {
            patrones.put("REFACTOR", contarOcurrencias(lower, "refactor", "clean", "code smell"));
        }
        
        // Contar patrones de seguridad
        if (lower.contains("security") || lower.contains("vulnerabilidad") || lower.contains("seguridad") || 
            lower.contains("hack") || lower.contains("injection")) {
            patrones.put("SEGURIDAD", contarOcurrencias(lower, "security", "vulnerabilidad", "seguridad"));
        }
        
        return patrones;
    }

    /**
     * üî¢ CONTAR OCURRENCIAS DE T√âRMINOS
     */
    private int contarOcurrencias(String texto, String... terminos) {
        int count = 0;
        for (String termino : terminos) {
            int index = 0;
            while ((index = texto.indexOf(termino, index)) != -1) {
                count++;
                index += termino.length();
            }
        }
        return count;
    }

    /**
     * üéØ GENERAR RECOMENDACI√ìN DE PRIORIDAD
     */
    private String generarRecomendacionPrioridad(Map<String, Integer> patrones) {
        int errores = patrones.get("ERRORES");
        int seguridad = patrones.get("SEGURIDAD");
        int optimizaciones = patrones.get("OPTIMIZACIONES");
        int refactor = patrones.get("REFACTOR");
        
        if (errores > 3 || seguridad > 0) {
            return "üî¥ PRIORIDAD M√ÅXIMA - Corregir errores cr√≠ticos y vulnerabilidades inmediatamente";
        } else if (errores > 0) {
            return "üü† PRIORIDAD ALTA - Resolver errores antes de continuar con mejoras";
        } else if (optimizaciones > 2) {
            return "üü° PRIORIDAD MEDIA - Implementar optimizaciones de performance";
        } else if (refactor > 0) {
            return "üîµ PRIORIDAD MEDIA-BAJA - Realizar refactorizaciones para mejorar mantenibilidad";
        } else {
            return "üü¢ PRIORIDAD BAJA - Mejoras generales y mantenimiento preventivo";
        }
    }

    /**
     * üìä EVALUAR NIVEL DE DETALLE - TURBOFURULADO
     */
    private String evaluarNivelDetalle(String respuestaIA) {
        if (respuestaIA == null || respuestaIA.trim().isEmpty()) {
            return "üì≠ SIN DETALLE - Respuesta vac√≠a";
        }
        
        // üìè M√âTRICAS CUANTITATIVAS
        int longitud = respuestaIA.length();
        int numeroLineas = respuestaIA.split("\n").length;
        int numeroPalabras = respuestaIA.split("\\s+").length;
        
        // üéØ M√âTRICAS CUALITATIVAS
        boolean tieneEjemplos = respuestaIA.contains("ejemplo") || respuestaIA.contains("Example") || 
                               respuestaIA.contains("por ejemplo");
        boolean tieneCodigo = respuestaIA.contains("```") || respuestaIA.contains("public class") || 
                             respuestaIA.contains("function") || respuestaIA.contains("def ");
        boolean tieneListado = respuestaIA.contains("- ") || respuestaIA.contains("‚Ä¢ ") || 
                              respuestaIA.matches(".*\\d+\\..*");
        boolean tieneRecomendaciones = respuestaIA.contains("recomend") || respuestaIA.contains("suger") || 
                                      respuestaIA.contains("deber√≠a") || respuestaIA.contains("podr√≠a");
        
        // üìà CALCULAR PUNTAJE DE DETALLE
        int puntaje = 0;
        
        // Puntaje por longitud
        if (longitud > 2000) puntaje += 3;
        else if (longitud > 1000) puntaje += 2;
        else if (longitud > 500) puntaje += 1;
        
        // Puntaje por caracter√≠sticas cualitativas
        if (tieneEjemplos) puntaje += 2;
        if (tieneCodigo) puntaje += 3;
        if (tieneListado) puntaje += 2;
        if (tieneRecomendaciones) puntaje += 2;
        
        // Puntaje por densidad de informaci√≥n
        double densidad = (double) numeroPalabras / Math.max(1, longitud) * 100;
        if (densidad > 15) puntaje += 2;
        else if (densidad > 10) puntaje += 1;
        
        // üéØ CLASIFICAR NIVEL DE DETALLE
        if (puntaje >= 10) {
            return "üèÜ DETALLE √âPICO - An√°lisis exhaustivo con ejemplos y c√≥digo";
        } else if (puntaje >= 7) {
            return "üìä DETALLE ALTO - An√°lisis completo con recomendaciones espec√≠ficas";
        } else if (puntaje >= 5) {
            return "üìù DETALLE MEDIO - An√°lisis adecuado con puntos clave";
        } else if (puntaje >= 3) {
            return "üîç DETALLE B√ÅSICO - An√°lisis general sin profundidad";
        } else {
            return "üìÑ DETALLE M√çNIMO - Respuesta breve sin desarrollo";
        }
    }

    /**
     * ‚ö° EVALUAR PRODUCTIVIDAD - TURBOFURULADO
     */
    private String evaluarProductividad(double productividad) {
        if (productividad <= 0) {
            return "üì≠ SIN DATOS - No se puede calcular productividad";
        }
        
        if (productividad > 5.0) {
            return "üöÄ PRODUCTIVIDAD √âPICA - " + String.format("%.2f", productividad) + " clases/segundo";
        } else if (productividad > 2.0) {
            return "‚ö° PRODUCTIVIDAD ALTA - " + String.format("%.2f", productividad) + " clases/segundo";
        } else if (productividad > 0.5) {
            return "üìä PRODUCTIVIDAD MEDIA - " + String.format("%.2f", productividad) + " clases/segundo";
        } else if (productividad > 0.1) {
            return "üê¢ PRODUCTIVIDAD BAJA - " + String.format("%.2f", productividad) + " clases/segundo";
        } else {
            return "ü¶• PRODUCTIVIDAD M√çNIMA - " + String.format("%.2f", productividad) + " clases/segundo";
        }
    }

    /**
     * üìà EVALUAR DENSIDAD - TURBOFURULADO
     */
    private String evaluarDensidad(double densidad) {
        if (densidad <= 0) {
            return "üì≠ SIN DENSIDAD - No hay datos para evaluar";
        }
        
        if (densidad > 0.8) {
            return "üî¥ DENSIDAD CR√çTICA - " + String.format("%.3f", densidad) + " (Concentraci√≥n extrema)";
        } else if (densidad > 0.5) {
            return "üü† DENSIDAD ALTA - " + String.format("%.3f", densidad) + " (Concentraci√≥n significativa)";
        } else if (densidad > 0.3) {
            return "üü° DENSIDAD MEDIA - " + String.format("%.3f", densidad) + " (Distribuci√≥n aceptable)";
        } else if (densidad > 0.1) {
            return "üü¢ DENSIDAD BAJA - " + String.format("%.3f", densidad) + " (Distribuci√≥n balanceada)";
        } else {
            return "üîµ DENSIDAD M√çNIMA - " + String.format("%.3f", densidad) + " (Distribuci√≥n dispersa)";
        }
    }

    /**
     * ‚úÖ EVALUAR TASA DE √âXITO - TURBOFURULADO
     */
    private String evaluarTasaExito(double tasaExito) {
        if (tasaExito <= 0) {
            return "üì≠ SIN √âXITOS - No hay operaciones exitosas registradas";
        }
        
        if (tasaExito >= 95.0) {
            return "üèÜ √âXITO √âPICO - " + String.format("%.1f%%", tasaExito) + " (Rendimiento excepcional)";
        } else if (tasaExito >= 85.0) {
            return "‚úÖ √âXITO ALTO - " + String.format("%.1f%%", tasaExito) + " (Rendimiento √≥ptimo)";
        } else if (tasaExito >= 70.0) {
            return "‚ö†Ô∏è  √âXITO ACEPTABLE - " + String.format("%.1f%%", tasaExito) + " (Rendimiento satisfactorio)";
        } else if (tasaExito >= 50.0) {
            return "üî∂ √âXITO MODERADO - " + String.format("%.1f%%", tasaExito) + " (Necesita mejoras)";
        } else if (tasaExito >= 25.0) {
            return "üî¥ √âXITO BAJO - " + String.format("%.1f%%", tasaExito) + " (Requiere atenci√≥n)";
        } else {
            return "üíÄ √âXITO CR√çTICO - " + String.format("%.1f%%", tasaExito) + " (Revisi√≥n urgente necesaria)";
        }
    }

    // Los m√©todos restantes se implementar√≠an siguiendo el mismo patr√≥n turbo...

    /**
     * üìä OBTENER ESTAD√çSTICAS DEL REPORTE MANAGER
     */
    public JSONObject obtenerEstadisticasReportes() {
        JSONObject stats = new JSONObject();
        
        stats.put("total_reportes_generados", totalReportesGenerados.get());
        stats.put("total_pdfs_generados", totalPDFsGenerados.get());
        stats.put("reportes_consolidados", reportesConsolidados.get());
        stats.put("estadisticas_tipo", new JSONObject(estadisticasTipoReporte));
        stats.put("cache_operaciones", cacheReportes.get("total_operaciones"));
        stats.put("cache_hits", cacheReportes.get("cache_hits"));
        stats.put("cache_misses", cacheReportes.get("cache_misses"));
        
        return stats;
    }

    /**
     * üßπ LIMPIAR CACHE DE REPORTES
     */
    public void limpiarCacheReportes() {
        int elementos = cacheReportes.size();
        cacheReportes.clear();
        inicializarCacheReportes();
        
        System.out.println("üßπ CACHE DE REPORTES LIMPIADO: " + elementos + " elementos eliminados");
        bitacora.info("Cache de reportes limpiado: " + elementos + " elementos");
    }

    // üéØ GETTERS PARA ESTAD√çSTICAS
    public int getTotalReportesGenerados() { return totalReportesGenerados.get(); }
    public int getTotalPDFsGenerados() { return totalPDFsGenerados.get(); }
    public int getReportesConsolidados() { return reportesConsolidados.get(); }
    public boolean isModoVerbose() { return modoVerbose; }
    public void setModoVerbose(boolean verbose) { this.modoVerbose = verbose; }
}