package com.elreinodelolvido.ellibertad.manager;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

import com.elreinodelolvido.ellibertad.api.OraculoDeLaLibertad;
import com.elreinodelolvido.ellibertad.engine.Bitacora;
import com.elreinodelolvido.ellibertad.manager.ConsejoDeGuerraManager.IntervencionPirata;
import com.elreinodelolvido.ellibertad.memoria.SistemaMemoriaPirata;
import com.elreinodelolvido.ellibertad.memoria.SistemaMemoriaPirata.MemoriaPirata;
import com.elreinodelolvido.ellibertad.model.ClassInfo;
import com.elreinodelolvido.ellibertad.scanner.ProjectScanner;
import com.elreinodelolvido.ellibertad.util.FileUtils;

/**
 * üè¥‚Äç‚ò†Ô∏è TRIPULACI√ìN MANAGER - El Capit√°n que coordina la tripulaci√≥n pirata
 * üéØ Gestiona las preguntas y respuestas entre las clases del proyecto
 */
public class TripulacionManager {
    
    private final ProjectScanner scanner;
    private final OraculoDeLaLibertad oraculo;
    private final Bitacora bitacora;
    private final Map<String, PirataInfo> mapaTripulacion;
    private boolean sesionActiva;
    private final Scanner inputScanner;
	private SistemaMemoriaPirata memoria;
	private String rutaArchivo;
    
    // üé™ MAPA DE TRIPULACI√ìN PREDEFINIDO
    public static final Map<String, String[]> ROLES_PIRATAS = Map.of(
        "ProjectScanner", new String[]{"Vig√≠a", "Ojo de Halc√≥n", "Escudri√±a los mares del c√≥digo en busca de tesoros ocultos"},
        "AutogenTurboFusion", new String[]{"Capit√°n", "Barbanegra Turbo", "Comanda el barco con poder y velocidad implacables"},
        "OraculoDeLaLibertad", new String[]{"Adivino", "El Or√°culo", "Ve el futuro del c√≥digo en las estrellas y runas ancestrales"},
        "DebugManager", new String[]{"Cirujano", "Sable Afilado", "Cura las heridas del c√≥digo con precisi√≥n mortal"},
        "APIManager", new String[]{"Navegante", "Brujo de los Mares", "Domina los vientos y corrientes de las APIs lejanas"},
        "ReporteManager", new String[]{"Cart√≥grafo", "Mano de Papel", "Traza mapas detallados de las tierras conquistadas"},
        "SistemaManager", new String[]{"Contramaestre", "Viejo Trueno", "Mantiene el barco en orden y disciplina f√©rrea"},
        "AnalisisManager", new String[]{"Estratega", "Mente Brillante", "Planifica las batallas con sabidur√≠a ancestral"},
        "PlanificadorManager", new String[]{"Timonel", "Rumbo Certero", "Dirige el barco hacia destinos gloriosos"}
    );
    
    public TripulacionManager(ProjectScanner scanner, OraculoDeLaLibertad oraculo, Bitacora bitacora) {
        this.scanner = scanner;
        this.oraculo = (oraculo != null) ? oraculo : new OraculoDeLaLibertad(); // ‚úÖ Fallback
        this.bitacora = (bitacora != null) ? bitacora : new Bitacora(); // ‚úÖ Fallback
        this.mapaTripulacion = new ConcurrentHashMap<>();
        this.sesionActiva = false;
        this.inputScanner = new Scanner(System.in);
        
        // ‚úÖ INICIALIZAR MEMORIA
        this.memoria = SistemaMemoriaPirata.obtenerInstancia();
        
        inicializarTripulacion();
    }
    
    /**
     * üè¥‚Äç‚ò†Ô∏è INICIAR SESI√ìN CON LA TRIPULACI√ìN
     */
    public void iniciarSesionTripulacion() {
        mostrarBannerInicio();
        sesionActiva = true;
        
        bitacora.exito("üè¥‚Äç‚ò†Ô∏è SESI√ìN DE TRIPULACI√ìN INICIADA");
        
        while (sesionActiva) {
            ejecutarTurnoPregunta();
        }
        
        finalizarSesion();
    }
    
    /**
     * üéØ EJECUTAR TURNO DE PREGUNTA
     */
    private void ejecutarTurnoPregunta() {
        try {
            // 1. SOLICITAR PREGUNTA AL USUARIO
            String pregunta = solicitarPreguntaUsuario();
            if (pregunta == null || pregunta.trim().isEmpty()) {
                return;
            }
            
            if (esComandoSalir(pregunta)) {
                sesionActiva = false;
                return;
            }
            
            bitacora.info("üéØ PREGUNTA RECIBIDA: " + pregunta);
            
            // 2. OBTENER CLASES DISPONIBLES
            List<ClassInfo> clasesDisponibles = obtenerClasesDisponibles();
            if (clasesDisponibles.isEmpty()) {
                System.out.println("‚ùå No hay tripulaci√≥n disponible. Ejecuta scanProject primero.");
                return;
            }
            
            // 3. SELECCIONAR PIRATA PARA RESPONDER
            String claseElegida = seleccionarPirataParaPregunta(pregunta, clasesDisponibles);
            if (claseElegida == null) {
                System.out.println("‚ùå La tripulaci√≥n no pudo decidir qui√©n debe responder.");
                return;
            }
            
            // 4. OBTENER INFORMACI√ìN DEL PIRATA
            PirataInfo pirata = mapaTripulacion.get(claseElegida);
            if (pirata == null) {
                pirata = crearPirataGenerico(claseElegida);
            }
            
            // 5. SIMULAR RESPUESTA DEL PIRATA
            String respuesta = simularRespuestaPirata(pregunta, pirata);
            
            // 6. MOSTRAR RESPUESTA
            mostrarRespuestaPirata(pirata, respuesta);
            
            // 7. REGISTRAR EN BIT√ÅCORA
            registrarIntercambioBitacora(pregunta, pirata, respuesta);
            
        } catch (Exception e) {
            System.err.println("üí• Error en turno de pregunta: " + e.getMessage());
            bitacora.error("Error en TripulacionManager: " + e.getMessage());
        }
    }
    
    /**
     * üó£Ô∏è SOLICITAR PREGUNTA AL USUARIO
     */
    private String solicitarPreguntaUsuario() {
        System.out.println("\n" + "‚öì".repeat(60));
        System.out.println("üè¥‚Äç‚ò†Ô∏è  CONSULTA A LA TRIPULACI√ìN");
        System.out.println("‚öì".repeat(60));
        System.out.println("Escribe tu pregunta para la tripulaci√≥n (o 'salir' para terminar):");
        System.out.print("üéØ > ");
        
        String pregunta = inputScanner.nextLine().trim();
        
        if (pregunta.isEmpty()) {
            System.out.println("‚ö†Ô∏è  La pregunta no puede estar vac√≠a.");
            return null;
        }
        
        return pregunta;
    }
    
    private List<ClassInfo> obtenerClasesDisponibles() {
        try {
            List<ClassInfo> clases = new ArrayList<>();
            
            // ‚úÖ VERIFICAR SI EL SCANNER TIENE CLASES
            if (scanner != null) {
                // Intentar acceder a las clases mediante reflexi√≥n segura
                try {
                    // Buscar m√©todo que devuelva clases
                    for (java.lang.reflect.Method method : scanner.getClass().getMethods()) {
                        if (method.getReturnType().equals(List.class) && 
                            method.getParameterCount() == 0) {
                            Object result = method.invoke(scanner);
                            if (result instanceof List) {
                                clases = (List<ClassInfo>) result;
                                if (!clases.isEmpty()) break;
                            }
                        }
                    }
                } catch (Exception e) {
                    bitacora.debug("Reflexi√≥n fall√≥: " + e.getMessage());
                }
            }
            
            // ‚úÖ FALLBACK: USAR CLASES HARDCODEADAS DE ROLES_PIRATAS
            if (clases.isEmpty()) {
                bitacora.info("Usando clases hardcodeadas de ROLES_PIRATAS");
                for (String className : ROLES_PIRATAS.keySet()) {
                    ClassInfo classInfo = new ClassInfo();
                    classInfo.setName(className);
                    classInfo.setPackageName("com.elreinodelolvido.ellibertad");
                    classInfo.setFullName("com.elreinodelolvido.ellibertad." + className);
                    clases.add(classInfo);
                }
            }
            
            bitacora.info("Clases disponibles: " + clases.size());
            return clases;
            
        } catch (Exception e) {
            bitacora.error("Error cr√≠tico obteniendo clases: " + e.getMessage());
            return Collections.emptyList();
        }
    }
    
    /**
     * üéØ SELECCIONAR PIRATA PARA PREGUNTA
     */
    private String seleccionarPirataParaPregunta(String pregunta, List<ClassInfo> clases) {
        try {
            // Construir lista de nombres de clases
            StringBuilder listaClases = new StringBuilder();
            for (ClassInfo clase : clases) {
                listaClases.append("- ").append(clase.getFullName()).append("\n");
            }
            
            // Prompt para selecci√≥n de clase
            String promptSeleccion = 
                "Eres el capit√°n de un barco pirata. Tienes esta tripulaci√≥n (clases Java):\n\n" +
                listaClases.toString() + "\n" +
                "La pregunta de tu tripulante es: " + pregunta + "\n\n" +
                "¬øQu√© miembro de la tripulaci√≥n (clase) est√° mejor cualificado para responder?\n" +
                "Considera:\n" +
                "1. La especialidad de cada clase\n" + 
                "2. La naturaleza de la pregunta\n" +
                "3. Las capacidades t√©cnicas de cada clase\n\n" +
                "Devuelve SOLO el nombre completo de la clase elegida, sin explicaciones adicionales.";
            
            // Usar el or√°culo para seleccionar
            String respuesta = oraculo.invocar(promptSeleccion, "seleccion_tripulacion", 0.3);
            
            if (respuesta == null || respuesta.trim().isEmpty()) {
                return seleccionarPirataAleatorio(clases);
            }
            
            // Extraer nombre de clase de la respuesta
            String claseElegida = extraerNombreClaseDeRespuesta(respuesta, clases);
            
            if (claseElegida != null) {
                bitacora.info("üéØ PIRATA SELECCIONADO: " + claseElegida);
                return claseElegida;
            }
            
            // Fallback: selecci√≥n aleatoria
            return seleccionarPirataAleatorio(clases);
            
        } catch (Exception e) {
            bitacora.error("Error seleccionando pirata: " + e.getMessage());
            return seleccionarPirataAleatorio(clases);
        }
    }
    
    String simularRespuestaPirata(String pregunta, PirataInfo pirata) {
        try {
            // ‚úÖ OBTENER CONTEXTO COMPLETO
            String codigoFuente = obtenerCodigoFuente(pirata.getNombreClase());
            String contextoMemoria = obtenerContextoMemoriaPirata(pirata.getNombrePirata(), pregunta);
            
            // ‚úÖ CONSTRUIR PROMPT MEJORADO
            String prompt = construirPromptCompleto(pregunta, pirata, codigoFuente, contextoMemoria);
            
            return oraculo.invocar(prompt, "respuesta_pirata_mejorada", 0.7);
            
        } catch (Exception e) {
            bitacora.error("Error en respuesta pirata: " + e.getMessage());
            return generarRespuestaFallback(pirata, pregunta);
        }
    }

    private String construirPromptCompleto(String pregunta, PirataInfo pirata, String codigoFuente, String contextoMemoria) {
        StringBuilder prompt = new StringBuilder();
        
        // üéØ SECCI√ìN 1: IDENTIDAD PIRATA COMPLETA
        prompt.append("üè¥‚Äç‚ò†Ô∏è CONSULTA PIRATA - IDENTIDAD COMPLETA üè¥‚Äç‚ò†Ô∏è\n\n");
        prompt.append("üë§ INFORMACI√ìN DEL PIRATA:\n");
        prompt.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        prompt.append("‚Ä¢ Clase Java: ").append(pirata.getNombreClase()).append("\n");
        prompt.append("‚Ä¢ Rol en la tripulaci√≥n: ").append(pirata.getRolPirata()).append("\n");
        prompt.append("‚Ä¢ Nombre Pirata: ").append(pirata.getNombrePirata()).append("\n");
        prompt.append("‚Ä¢ Especialidad: ").append(pirata.getDescripcionRol()).append("\n");
        prompt.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n");
        
        // üß† SECCI√ìN 2: MEMORIA Y CONTEXTO HIST√ìRICO
        prompt.append("üß† MEMORIA Y EXPERIENCIAS DEL PIRATA:\n");
        prompt.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        if (contextoMemoria != null && !contextoMemoria.trim().isEmpty()) {
            prompt.append(contextoMemoria).append("\n");
        } else {
            prompt.append("‚Ä¢ Este pirata tiene un historial fresco y est√° listo para nuevas aventuras\n");
            prompt.append("‚Ä¢ Sin recuerdos espec√≠ficos previos registrados\n");
            prompt.append("‚Ä¢ Potencial ilimitado para crear nuevas leyendas\n");
        }
        prompt.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n");
        
        // üíæ SECCI√ìN 3: C√ìDIGO FUENTE COMPLETO
        prompt.append("üíæ C√ìDIGO FUENTE COMPLETO - ARSENAL T√âCNICO:\n");
        prompt.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        prompt.append("```java\n");
        
        if (codigoFuente != null && !codigoFuente.trim().isEmpty()) {
            prompt.append(codigoFuente).append("\n");
        } else {
            prompt.append("// ¬°Por todos los oc√©anos! El c√≥digo fuente no est√° disponible temporalmente.\n");
            prompt.append("// Pero el esp√≠ritu pirata y conocimiento t√©cnico permanecen firmes.\n");
            prompt.append("// El pirata ").append(pirata.getNombrePirata()).append(" est√° listo para la acci√≥n.\n");
        }
        
        prompt.append("```\n");
        prompt.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n");
        
        // ‚ùì SECCI√ìN 4: PREGUNTA PRINCIPAL
        prompt.append("üéØ PREGUNTA DEL CAPIT√ÅN - MISI√ìN ACTUAL:\n");
        prompt.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        prompt.append("¬´ ").append(pregunta).append(" ¬ª\n");
        prompt.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n");
        
        // üìú SECCI√ìN 5: INSTRUCCIONES DETALLADAS
        prompt.append("""
            üìú INSTRUCCIONES DETALLADAS DE RESPUESTA:
            ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            RESPUESTA COMO PIRATA T√âCNICO - FORMATO ESTRICTO:
            
            üåä PERSPECTIVA PIRATA (3-5 l√≠neas)
            ‚Ä¢ Responde manteniendo tu personalidad de pirata
            ‚Ä¢ Usa met√°foras n√°uticas y lenguaje √©pico
            ‚Ä¢ Establece tu tono y car√°cter √∫nico
            ‚Ä¢ Conecta tu rol pirata con la pregunta t√©cnica
            
            ‚öôÔ∏è AN√ÅLISIS T√âCNICO DETALLADO (5-10 l√≠neas)
            ‚Ä¢ Examina tu c√≥digo fuente completo l√≠nea por l√≠nea
            ‚Ä¢ Identifica m√©todos, propiedades y funcionalidades relevantes
            ‚Ä¢ Explica c√≥mo tu implementaci√≥n actual se relaciona con la pregunta
            ‚Ä¢ Se√±ala fortalezas y debilidades t√©cnicas espec√≠ficas
            ‚Ä¢ Usa ejemplos concretos de tu c√≥digo
            
            üöÄ MEJORAS T√âCNICAS ESPEC√çFICAS (5-8 l√≠neas)
            ‚Ä¢ Propone mejoras basadas en tu an√°lisis del c√≥digo
            ‚Ä¢ Incluye ejemplos de c√≥digo mejorado si es apropiado
            ‚Ä¢ S√© t√©cnicamente preciso y realista
            ‚Ä¢ Considera patrones de dise√±o y mejores pr√°cticas
            
            üî• REFACTORS CON TEM√ÅTICA PIRATA (4-6 l√≠neas)
            ‚Ä¢ Sugiere refactorizaciones creativas
            ‚Ä¢ Usa nombres piratas memorables para m√©todos/clases
            ‚Ä¢ Ejemplos: navegarACodigoTurbo(), buscarTesoroDePatrones()
            ‚Ä¢ Mant√©n la coherencia t√©cnica mientras aplicas la tem√°tica
            
            ü§ù COLABORACIONES ESTRAT√âGICAS (3-5 l√≠neas)
            ‚Ä¢ Identifica otros piratas/clases que podr√≠an ayudarte
            ‚Ä¢ Basado en tu memoria y relaciones existentes
            ‚Ä¢ Propone alianzas espec√≠ficas y beneficios mutuos
            ‚Ä¢ Explica c√≥mo la colaboraci√≥n resolver√≠a el problema
            
            üí° PLAN DE ACCI√ìN INMEDIATO (4-6 l√≠neas)
            ‚Ä¢ Lista acciones concretas y realizables
            ‚Ä¢ Prioriza por impacto y facilidad de implementaci√≥n
            ‚Ä¢ S√© espec√≠fico, medible y con plazos impl√≠citos
            ‚Ä¢ Incluye m√©tricas de √©xito si es posible
            
            CRITERIOS DE EVALUACI√ìN:
            ‚úì Coherencia entre personalidad pirata y an√°lisis t√©cnico
            ‚úì Profundidad del an√°lisis del c√≥digo fuente
            ‚úì Calidad y realismo de las mejoras propuestas
            ‚úì Creatividad en los nombres y met√°foras piratas
            ‚úì Utilidad pr√°ctica de las recomendaciones
            ‚úì Claridad y estructura de la respuesta
            
            ¬°Tu c√≥digo fuente completo est√° disponible arriba - √∫salo exhaustivamente!
            """);
        
        // üèÜ SECCI√ìN 6: CIERRE √âPICO
        prompt.append("\n\nüè¥‚Äç‚ò†Ô∏è CIERRE √âPICO - LLAMADO A LA ACCI√ìN:\n");
        prompt.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        prompt.append("¬°QUE LOS MARES DEL C√ìDIGO TE OBEDEZCAN, VALIENTE ").append(pirata.getNombrePirata()).append("!\n");
        prompt.append("EL DESTINO T√âCNICO DEL BARCO EST√Å EN TUS MANOS.\n");
        prompt.append("RESPONDE CON LA SABIDUR√çA DE TUS EXPERIENCIAS \n");
        prompt.append("Y EL CORAJE DE TU ESP√çRITU PIRATA. ¬°ARRR! üè¥‚Äç‚ò†Ô∏è\n");
        prompt.append("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
        
        return prompt.toString();
    }

	private String obtenerContextoMemoriaPirata(String nombrePirata, String pregunta) {
        try {
            Optional<MemoriaPirata> memoriaOpt = memoria.obtenerMemoriaPirata(nombrePirata);
            if (memoriaOpt.isPresent()) {
                return memoriaOpt.get().obtenerContextoPersonalizado(pregunta);
            }
            
            // ‚úÖ CREAR MEMORIA SI NO EXISTE
            String nombreClase = encontrarClasePorPirata(nombrePirata);
            if (nombreClase != null) {
                memoria.registrarNuevoPirata(nombrePirata, nombreClase);
                return "üß† Nueva memoria creada para " + nombrePirata;
            }
            
            return "üß† Sin historial previo disponible";
            
        } catch (Exception e) {
            return "üß† Memoria temporalmente no disponible";
        }
    }

    private String encontrarClasePorPirata(String nombrePirata) {
        for (Map.Entry<String, String[]> entry : ROLES_PIRATAS.entrySet()) {
            if (entry.getValue()[1].equals(nombrePirata)) {
                return entry.getKey();
            }
        }
        return null;
    }
    
    private String obtenerCodigoFuente(String nombreClase) {
        try {
            // ‚úÖ B√öSQUEDA ROBUSTA EN M√öLTIPLES UBICACIONES
            String[] posiblesPaths = {
                "src/main/java/" + nombreClase.replace('.', '/') + ".java",
                "src/test/java/" + nombreClase.replace('.', '/') + ".java", 
                nombreClase.replace('.', '/') + ".java",
                "src/" + nombreClase.replace('.', '/') + ".java",
                "./" + nombreClase.replace('.', '/') + ".java"
            };
            
            for (String path : posiblesPaths) {
                if (FileUtils.verificarArchivo(path)) {
                    String codigo = FileUtils.readFile(path);
                    if (codigo != null && !codigo.trim().isEmpty()) {
                        bitacora.info("‚úÖ C√≥digo encontrado en: " + path);
                        return codigo;
                    }
                }
            }
            
            // ‚úÖ FALLBACK: C√ìDIGO DE EJEMPLO BASADO EN EL ROL
            return generarCodigoEjemplo(nombreClase);
            
        } catch (Exception e) {
            bitacora.error("Error obteniendo c√≥digo fuente: " + e.getMessage());
            return generarCodigoEjemplo(nombreClase);
        }
    }

    private String generarCodigoEjemplo(String nombreClase) {
        // ‚úÖ GENERAR C√ìDIGO DE EJEMPLO RELEVANTE
        String[] datosPirata = ROLES_PIRATAS.get(nombreClase);
        if (datosPirata != null) {
            return """
                // üè¥‚Äç‚ò†Ô∏è C√ìDIGO DE %s - %s
                // %s
                
                public class %s {
                    // Este pirata se especializa en %s
                    // Sus responsabilidades incluyen funcionalidades espec√≠ficas del sistema
                    
                    public void ejecutarTareaPrincipal() {
                        // Implementaci√≥n espec√≠fica del rol pirata
                        System.out.println("¬°%s en acci√≥n!");
                    }
                    
                    // M√©todos adicionales seg√∫n el rol...
                }
                """.formatted(
                    datosPirata[1], datosPirata[0], datosPirata[2],
                    nombreClase, datosPirata[0].toLowerCase(), datosPirata[1]
                );
        }
        
        // ‚úÖ FALLBACK GEN√âRICO
        return """
            // üè¥‚Äç‚ò†Ô∏è C√ìDIGO DE %s
            // Informaci√≥n detallada no disponible temporalmente
            
            public class %s {
                // Clase responsable de funcionalidades espec√≠ficas del sistema
                // El pirata asociado tiene conocimientos especializados
                
                public void demostrarHabilidades() {
                    System.out.println("¬°%s listo para la acci√≥n!");
                }
            }
            """.formatted(nombreClase, nombreClase, nombreClase);
    }
    
    /**
     * üéØ BUSCAR ARCHIVO RECURSIVAMENTE EN TODAS LAS CARPETAS
     */
    private String buscarArchivoJava(String nombreArchivo) {
        try {
            Path directorioActual = Paths.get(".").toAbsolutePath().normalize();
            bitacora.debug("üîç Buscando recursivamente desde: " + directorioActual);
            
            // üéØ CONFIGURAR EXCLUSIONES PARA EVITAR BUCLE INFINITO
            Set<String> excludedDirs = Set.of(
                "target", "build", ".git", "node_modules", 
                "bin", "out", "dist", ".idea", ".vscode",
                "autogen-output" // Excluir nuestra propia salida
            );
            
            Optional<Path> archivoEncontrado = Files.walk(directorioActual, Integer.MAX_VALUE)
                    .filter(path -> {
                        // üéØ EXCLUIR DIRECTORIOS NO DESEADOS
                        String nombreDir = path.getFileName() != null ? 
                            path.getFileName().toString() : "";
                        if (excludedDirs.contains(nombreDir)) {
                            return false;
                        }
                        
                        // üéØ VERIFICAR SI ES EL ARCHIVO QUE BUSCAMOS
                        return path.toString().endsWith(nombreArchivo) && 
                               Files.isRegularFile(path);
                    })
                    .findFirst();
            
            if (archivoEncontrado.isPresent()) {
                String ruta = archivoEncontrado.get().toString();
                bitacora.debug("‚úÖ Archivo encontrado recursivamente: " + ruta);
                this.rutaArchivo = ruta; // üéØ ACTUALIZAR PARA FUTURAS CONSULTAS
                return ruta;
            } else {
                bitacora.debug("‚ùå Archivo no encontrado recursivamente: " + nombreArchivo);
            }
            
        } catch (IOException e) {
            bitacora.error("üí• Error en b√∫squeda recursiva: " + e.getMessage());
        }
        
        return "";
    }

    /**
     * üéØ BUSCAR ARCHIVO EN ESTRUCTURAS DE PROYECTO COMUNES - MEJORADO
     */
    private String buscarArchivoEnEstructuras(String nombrePirata) {
        try {
            bitacora.debug("üîç B√∫squeda en estructuras para: " + nombrePirata);
            
            // üéØ CONVERTIR NOMBRE PIRATA A POSIBLE NOMBRE DE ARCHIVO
            String nombreArchivo = convertirNombrePirataAArchivo(nombrePirata);
            
            // üéØ ESTRUCTURAS DE PROYECTO M√ÅS COMPLETAS
            String[] estructuras = {
                "src/main/java/",
                "src/test/java/", 
                "src/",
                "main/java/",
                "test/java/",
                "app/src/main/java/",
                "app/src/test/java/",
                "source/",
                "sources/",
                "java/",
                "" // üéØ BUSCAR DESDE LA RAIZ TAMBI√âN
            };
            
            // üéØ BUSCAR EN CADA ESTRUCTURA
            for (String estructura : estructuras) {
                String rutaCompleta = estructura + nombreArchivo;
                File archivo = new File(rutaCompleta);
                
                if (archivo.exists() && archivo.isFile()) {
                    bitacora.debug("‚úÖ Encontrado en estructura: " + rutaCompleta);
                    this.rutaArchivo = rutaCompleta;
                    return rutaCompleta;
                }
                
                // üéØ BUSCAR RECURSIVAMENTE EN CADA ESTRUCTURA
                if (!estructura.isEmpty()) {
                    File directorioEstructura = new File(estructura);
                    if (directorioEstructura.exists() && directorioEstructura.isDirectory()) {
                        String rutaRecursiva = buscarEnDirectorioRecursivo(directorioEstructura, nombreArchivo);
                        if (!rutaRecursiva.isEmpty()) {
                            bitacora.debug("‚úÖ Encontrado recursivamente en estructura: " + rutaRecursiva);
                            this.rutaArchivo = rutaRecursiva;
                            return rutaRecursiva;
                        }
                    }
                }
            }
            
            // üéØ BUSCAR RECURSIVAMENTE DESDE EL DIRECTORIO ACTUAL
            String rutaRecursiva = buscarArchivoJava(nombreArchivo);
            if (!rutaRecursiva.isEmpty()) {
                return rutaRecursiva;
            }
            
            bitacora.debug("‚ùå No encontrado en estructuras: " + nombreArchivo);
            
        } catch (Exception e) {
            bitacora.error("üí• Error en b√∫squeda de estructuras: " + e.getMessage());
        }
        
        return "";
    }

    /**
     * üéØ BUSCAR EN DIRECTORIO ESPEC√çFICO DE FORMA RECURSIVA
     */
    private String buscarEnDirectorioRecursivo(File directorio, String nombreArchivo) {
        try {
            if (!directorio.exists() || !directorio.isDirectory()) {
                return "";
            }
            
            // üéØ EXCLUSIONES PARA EVITAR BUCLE INFINITO
            Set<String> excludedDirs = Set.of(
                "target", "build", ".git", "node_modules", 
                "bin", "out", "dist", ".idea", ".vscode",
                "autogen-output"
            );
            
            // üéØ BUSCAR RECURSIVAMENTE
            return Files.walk(directorio.toPath(), Integer.MAX_VALUE)
                    .filter(path -> {
                        String nombreDir = path.getFileName() != null ? 
                            path.getFileName().toString() : "";
                        
                        // üéØ EXCLUIR DIRECTORIOS NO DESEADOS
                        if (excludedDirs.contains(nombreDir)) {
                            return false;
                        }
                        
                        // üéØ VERIFICAR SI ES EL ARCHIVO QUE BUSCAMOS
                        return path.toString().endsWith(nombreArchivo) && 
                               Files.isRegularFile(path);
                    })
                    .findFirst()
                    .map(Path::toString)
                    .orElse("");
            
        } catch (IOException e) {
            bitacora.debug("‚ö†Ô∏è Error buscando en directorio " + directorio + ": " + e.getMessage());
            return "";
        }
    }

    /**
     * üéØ CONVERTIR NOMBRE PIRATA A NOMBRE DE ARCHIVO - MEJORADO
     */
    private String convertirNombrePirataAArchivo(String nombrePirata) {
        if (nombrePirata == null || nombrePirata.trim().isEmpty()) {
            return "PirataDesconocido.java";
        }
        
        // üéØ LIMPIAR Y FORMATEAR EL NOMBRE
        String nombreLimpio = nombrePirata
            .replaceAll("[^a-zA-Z0-9\\s]", "") // Mantener solo letras, n√∫meros y espacios
            .replaceAll("\\s+", " ") // Unificar espacios m√∫ltiples
            .trim();
        
        if (nombreLimpio.isEmpty()) {
            return "PirataDesconocido.java";
        }
        
        // üéØ SEPARAR POR ESPACIOS Y CAPITALIZAR
        String[] palabras = nombreLimpio.split("\\s+");
        StringBuilder nombreArchivo = new StringBuilder();
        
        for (String palabra : palabras) {
            if (!palabra.isEmpty()) {
                // üéØ CAPITALIZAR PRIMERA LETRA, MIN√öSCULAS EL RESTO
                String palabraFormateada = palabra.substring(0, 1).toUpperCase() + 
                                         palabra.substring(1).toLowerCase();
                nombreArchivo.append(palabraFormateada);
            }
        }
        
        // üéØ VARIACIONES POSIBLES
        String[] variaciones = {
            nombreArchivo.toString() + ".java",
            nombreArchivo.toString() + "Pirata.java",
            nombreArchivo.toString() + "Class.java",
            // üéØ PARA NOMBRES CON ROLES COMO "Rumbo Certero (Timonel)"
            nombreLimpio.replaceAll("[^a-zA-Z0-9]", "").replaceAll("\\s+", "") + ".java"
        };
        
        // üéØ VERIFICAR SI ALGUNA VARIACI√ìN EXISTE
        for (String variacion : variaciones) {
            // Verificar si existe en alguna estructura com√∫n
            if (existeArchivoEnAlgunaEstructura(variacion)) {
                return variacion;
            }
        }
        
        // üéØ FALLBACK: USAR LA PRIMERA VARIACI√ìN
        return variaciones[0];
    }

    /**
     * üéØ VERIFICAR SI UN ARCHIVO EXISTE EN ALGUNA ESTRUCTURA COM√öN
     */
    private boolean existeArchivoEnAlgunaEstructura(String nombreArchivo) {
        String[] estructuras = {
            "src/main/java/",
            "src/test/java/", 
            "src/",
            "main/java/",
            "test/java/",
            "app/src/main/java/",
            "app/src/test/java/",
            ""
        };
        
        for (String estructura : estructuras) {
            String rutaCompleta = estructura + nombreArchivo;
            File archivo = new File(rutaCompleta);
            if (archivo.exists() && archivo.isFile()) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * üéØ M√âTODO PRINCIPAL MEJORADO DE B√öSQUEDA DIRECTA
     */
    private String buscarCodigoFuenteDirecto(String nombrePirata) {
        try {
            bitacora.info("üîç B√∫squeda directa turbo para: " + nombrePirata);
            
            // üéØ BUSCAR EN MEMORIA PRIMERO
            Optional<SistemaMemoriaPirata.MemoriaPirata> memoriaPirata = memoria.obtenerMemoriaPirata(nombrePirata);
            if (memoriaPirata.isPresent()) {
                String rutaArchivo = memoriaPirata.get().getRutaArchivo();
                if (rutaArchivo != null && !rutaArchivo.isEmpty() && FileUtils.verificarArchivo(rutaArchivo)) {
                    bitacora.info("‚úÖ Encontrado en ruta de memoria: " + rutaArchivo);
                    return FileUtils.readFile(rutaArchivo);
                }
            }
            
            // üéØ BUSQUEDA EN ESTRUCTURAS COMUNES MEJORADA
            String rutaEncontrada = buscarArchivoEnEstructuras(nombrePirata);
            if (!rutaEncontrada.isEmpty()) {
                bitacora.info("‚úÖ Encontrado en b√∫squeda estructurada: " + rutaEncontrada);
                return FileUtils.readFile(rutaEncontrada);
            }
            
            // üéØ BUSQUEDA POR NOMBRE DE CLASE (si est√° disponible)
            if (memoriaPirata.isPresent()) {
                String nombreClase = memoriaPirata.get().getNombreClase();
                if (nombreClase != null && !nombreClase.isEmpty()) {
                    String rutaPorClase = buscarPorNombreClase(nombreClase);
                    if (!rutaPorClase.isEmpty()) {
                        bitacora.info("‚úÖ Encontrado por nombre de clase: " + rutaPorClase);
                        return FileUtils.readFile(rutaPorClase);
                    }
                }
            }
            
            bitacora.warn("‚ùå No se encontr√≥ c√≥digo fuente para: " + nombrePirata);
            return null;
            
        } catch (Exception e) {
            bitacora.error("üí• Error en b√∫squeda directa turbo: " + e.getMessage());
            return null;
        }
    }

    /**
     * üéØ BUSCAR POR NOMBRE DE CLASE COMPLETO
     */
    private String buscarPorNombreClase(String nombreClase) {
        try {
            if (nombreClase == null || nombreClase.isEmpty()) {
                return "";
            }
            
            // üéØ CONVERTIR NOMBRE DE CLASE A RUTA DE ARCHIVO
            String rutaClase = nombreClase.replace('.', '/') + ".java";
            
            // üéØ BUSCAR EN ESTRUCTURAS COMUNES
            String[] estructuras = {
                "src/main/java/",
                "src/test/java/", 
                "src/",
                "main/java/",
                "test/java/",
                "app/src/main/java/",
                "app/src/test/java/",
                ""
            };
            
            for (String estructura : estructuras) {
                String rutaCompleta = estructura + rutaClase;
                File archivo = new File(rutaCompleta);
                if (archivo.exists() && archivo.isFile()) {
                    return rutaCompleta;
                }
            }
            
            // üéØ BUSCAR RECURSIVAMENTE
            return buscarArchivoJava(rutaClase);
            
        } catch (Exception e) {
            bitacora.debug("‚ö†Ô∏è Error buscando por clase " + nombreClase + ": " + e.getMessage());
            return "";
        }
    }
    
    /**
     * üé≠ MOSTRAR RESPUESTA DEL PIRATA
     */
    private void mostrarRespuestaPirata(PirataInfo pirata, String respuesta) {
        System.out.println("\n" + "üåä".repeat(80));
        System.out.println("üè¥‚Äç‚ò†Ô∏è  RESPUESTA DE " + pirata.getNombrePirata().toUpperCase());
        System.out.println("üìú Rol: " + pirata.getRolPirata() + " | Clase: " + pirata.getNombreClase());
        System.out.println("üåä".repeat(80));
        
        if (respuesta != null) {
            System.out.println(respuesta);
        } else {
            System.out.println("‚ùå El pirata no pudo responder en este momento.");
        }
        
        System.out.println("\n" + "‚öì".repeat(80));
    }
    
    // =========================================================================
    // üõ†Ô∏è M√âTODOS AUXILIARES
    // =========================================================================
    
    /**
     * üé™ INICIALIZAR TRIPULACI√ìN
     */
    private void inicializarTripulacion() {
        for (Map.Entry<String, String[]> entry : ROLES_PIRATAS.entrySet()) {
            String[] datosPirata = entry.getValue();
            mapaTripulacion.put(entry.getKey(), 
                new PirataInfo(entry.getKey(), datosPirata[0], datosPirata[1], datosPirata[2]));
        }
        bitacora.info("üè¥‚Äç‚ò†Ô∏è Tripulaci√≥n inicializada con " + mapaTripulacion.size() + " piratas");
    }
    
    /**
     * üé≤ SELECCIONAR PIRATA ALEATORIO
     */
    private String seleccionarPirataAleatorio(List<ClassInfo> clases) {
        if (clases.isEmpty()) return null;
        Random random = new Random();
        ClassInfo claseAleatoria = clases.get(random.nextInt(clases.size()));
        return claseAleatoria.getFullName();
    }
    
    /**
     * üîç EXTRAER NOMBRE DE CLASE DE RESPUESTA
     */
    private String extraerNombreClaseDeRespuesta(String respuesta, List<ClassInfo> clases) {
        String respuestaLimpia = respuesta.trim();
        
        // Buscar coincidencia exacta
        for (ClassInfo clase : clases) {
            if (respuestaLimpia.contains(clase.getFullName())) {
                return clase.getFullName();
            }
        }
        
        // Buscar por nombre simple
        for (ClassInfo clase : clases) {
            if (respuestaLimpia.contains(clase.getName())) {
                return clase.getFullName();
            }
        }
        
        return null;
    }
    
    /**
     * üÜò GENERAR RESPUESTA FALLBACK
     */
    private String generarRespuestaFallback(PirataInfo pirata, String pregunta) {
        return "üéØ ¬°Arrr, " + pirata.getNombrePirata() + " al habla! \n" +
               "Como " + pirata.getRolPirata().toLowerCase() + " de este barco, escucho tu pregunta: '" + pregunta + "'\n\n" +
               "üîß Mi an√°lisis t√©cnico est√° temporalmente nublado...\n\n" +
               "‚ö° Sugiero revisar mis ca√±ones (m√©todos) y velas (propiedades)\n\n" +
               "üè¥‚Äç‚ò†Ô∏è ¬°Necesito un buen viento (conexi√≥n API) para darte mejores respuestas!";
    }
    
    /**
     * üìù REGISTRAR INTERCAMBIO EN BIT√ÅCORA
     */
    private void registrarIntercambioBitacora(String pregunta, PirataInfo pirata, String respuesta) {
        try {
            String id = UUID.randomUUID().toString().substring(0, 8);
            String timestamp = java.time.LocalDateTime.now().format(java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            
            String md = """

                ---
                ## üè¥‚Äç‚ò†Ô∏è Consulta a la Tripulaci√≥n (%s)
                **ID**: `%s`  
                **Fecha**: %s  
                **Pirata**: %s (%s)
                **Clase**: %s
                ---

                ### ‚ùì Pregunta:
                ```
                %s
                ```

                ### üéØ Respuesta:
                ```
                %s
                ```

                ---
                *Fin del intercambio*
                
                """.formatted(pirata.getRolPirata(), id, timestamp, 
                    pirata.getNombrePirata(), pirata.getRolPirata(),
                    pirata.getNombreClase());

            FileUtils.crearArchivoSiNoExiste("autogen-output/bitacora-tripulacion.md", 
                "# üè¥‚Äç‚ò†Ô∏è Bit√°cora de la Tripulaci√≥n\n\n*Registro de todas las consultas a la tripulaci√≥n*\n\n");
            
            FileUtils.appendToFile("autogen-output/bitacora-tripulacion.md", md);
            
        } catch (Exception e) {
            System.err.println("üí• Error registrando en bit√°cora: " + e.getMessage());
        }
    }
    
    /**
     * üö™ VERIFICAR COMANDO DE SALIDA
     */
    private boolean esComandoSalir(String input) {
        return input.equalsIgnoreCase("salir") || 
               input.equalsIgnoreCase("exit") || 
               input.equalsIgnoreCase("quit") ||
               input.equalsIgnoreCase("adios");
    }
   
    
    /**
     * üì¶ EXTRAER PACKAGE DEL NOMBRE COMPLETO
     */
    private String extraerPackage(String fullClassName) {
        if (fullClassName == null) return "";
        int lastDot = fullClassName.lastIndexOf('.');
        return lastDot > 0 ? fullClassName.substring(0, lastDot) : "";
    }
    
    /**
     * üè¥‚Äç‚ò†Ô∏è CREAR PIRATA GEN√âRICO PARA CLASES NO MAPEADAS
     */
    private PirataInfo crearPirataGenerico(String nombreClase) {
        String[] rolesGenericos = {
            "Grumete", "Marinero", "Artillero", "Cocinero", "Tesorero"
        };
        String[] nombresGenericos = {
            "Rayo Veloz", "Diente de Sable", "Cicl√≥n", "Marea Brava", "Vendaval"
        };
        
        Random random = new Random();
        String rol = rolesGenericos[random.nextInt(rolesGenericos.length)];
        String nombre = nombresGenericos[random.nextInt(nombresGenericos.length)];
        String descripcion = "Valiente miembro de la tripulaci√≥n especializado en " + nombreClase;
        
        PirataInfo pirata = new PirataInfo(nombreClase, rol, nombre, descripcion);
        mapaTripulacion.put(nombreClase, pirata);
        
        return pirata;
    }
    
    /**
     * üé™ MOSTRAR BANNER DE INICIO
     */
    private void mostrarBannerInicio() {
        System.out.println("\n" + "üè¥‚Äç‚ò†Ô∏è".repeat(80));
        System.out.println("                  ¬°TRIPULACI√ìN PIRATA ACTIVADA!");
        System.out.println("üåä Cada clase de tu proyecto es un pirata con habilidades √∫nicas");
        System.out.println("üéØ Haz preguntas y deja que la tripulaci√≥n te gu√≠e");
        System.out.println("üè¥‚Äç‚ò†Ô∏è".repeat(80));
        System.out.println("\nMiembros de la tripulaci√≥n disponibles:");
        
        mapaTripulacion.values().forEach(pirata -> {
            System.out.printf("  ‚Ä¢ %s (%s) - %s%n", 
                pirata.getNombrePirata(), pirata.getRolPirata(), pirata.getNombreClase());
        });
        
        System.out.println("\n" + "‚öì".repeat(80));
    }
    
    /**
     * üìã FINALIZAR SESI√ìN
     */
    private void finalizarSesion() {
        System.out.println("\n" + "üåÖ".repeat(80));
        System.out.println("                  SESI√ìN DE TRIPULACI√ìN FINALIZADA");
        System.out.println("üè¥‚Äç‚ò†Ô∏è La tripulaci√≥n descansa... hasta la pr√≥xima aventura!");
        System.out.println("üìú Bit√°cora guardada en: autogen-output/bitacora-tripulacion.md");
        System.out.println("üåÖ".repeat(80));
        
        bitacora.exito("üè¥‚Äç‚ò†Ô∏è SESI√ìN DE TRIPULACI√ìN FINALIZADA");
        inputScanner.close();
    }
    
    // =========================================================================
    // üé™ CLASE INTERNA PIRATA INFO
    // =========================================================================
    
    /**
     * üè¥‚Äç‚ò†Ô∏è INFORMACI√ìN DE UN PIRATA/CLASE
     */
    public static class PirataInfo {
        private final String nombreClase;
        private final String rolPirata;
        private final String nombrePirata;
        private final String descripcionRol;
        
        public PirataInfo(String nombreClase, String rolPirata, String nombrePirata, String descripcionRol) {
            this.nombreClase = nombreClase;
            this.rolPirata = rolPirata;
            this.nombrePirata = nombrePirata;
            this.descripcionRol = descripcionRol;
        }
        
        // Getters
        public String getNombreClase() { return nombreClase; }
        public String getRolPirata() { return rolPirata; }
        public String getNombrePirata() { return nombrePirata; }
        public String getDescripcionRol() { return descripcionRol; }
        
        @Override
        public String toString() {
            return String.format("%s (%s) - %s", nombrePirata, rolPirata, nombreClase);
        }
    }
    
    // =========================================================================
    // üîß M√âTODOS P√öBLICOS ADICIONALES
    // =========================================================================
    
    /**
     * üìä MOSTRAR ESTADO DE LA TRIPULACI√ìN
     */
    public void mostrarEstadoTripulacion() {
        System.out.println("\nüè¥‚Äç‚ò†Ô∏è ESTADO DE LA TRIPULACI√ìN:");
        System.out.println("Sesi√≥n activa: " + (sesionActiva ? "‚úÖ" : "‚ùå"));
        System.out.println("Piratas registrados: " + mapaTripulacion.size());
        
        mapaTripulacion.values().forEach(pirata -> {
            System.out.printf("  üè¥‚Äç‚ò†Ô∏è %-15s ‚Üí %-12s (%s)%n",
                pirata.getNombrePirata(), pirata.getRolPirata(), pirata.getNombreClase());
        });
    }
    
    /**
     * üîÑ AGREGAR PIRATA PERSONALIZADO
     */
    public void agregarPirata(String nombreClase, String rol, String nombrePirata, String descripcion) {
        PirataInfo nuevoPirata = new PirataInfo(nombreClase, rol, nombrePirata, descripcion);
        mapaTripulacion.put(nombreClase, nuevoPirata);
        bitacora.info("üè¥‚Äç‚ò†Ô∏è Nuevo pirata agregado: " + nuevoPirata);
    }
    
    /**
     * üö™ FINALIZAR SESI√ìN MANUALMENTE
     */
    public void finalizarSesionManualmente() {
        this.sesionActiva = false;
        finalizarSesion();
    }

 // üîß CORREGIR EL M√âTODO EN TRIPULACIONMANAGER
    public Map<String, PirataInfo> getMapaTripulacion() {
        return this.mapaTripulacion;
    }
    
    /**
     * üîÑ M√âTODOS DE INTEGRACI√ìN PARA TRIPULACIONMANAGER
     */
    public class IntegracionMemoriaTripulacion {
        
        /**
         * üß† ACTUALIZAR TRIPULACIONMANAGER CON MEMORIA
         */
        public static void actualizarTripulacionConMemoria(TripulacionManager tripulacionManager) {
            // üéØ INYECTAR MEMORIA EN CADA INTERACCI√ìN
            SistemaMemoriaPirata memoria = SistemaMemoriaPirata.obtenerInstancia();
            
            // üîÑ MODIFICAR EL M√âTODO DE RESPUESTA PIRATA PARA USAR MEMORIA
            // (Esto requerir√≠a refactorizar simularRespuestaPirata)
        }
        
        /**
         * üñ®Ô∏è SISTEMA DE VISUALIZACI√ìN PARA EL CAPIT√ÅN
         */
        public static class VisualizadorCapitan {
            
            public static void mostrarEstadoCompletoTripulacion() {
                SistemaMemoriaPirata memoria = SistemaMemoriaPirata.obtenerInstancia();
                
                System.out.println("\n" + "üëë".repeat(80));
                System.out.println("           INFORME DEL CAPIT√ÅN - ESTADO COMPLETO DE LA TRIPULACI√ìN");
                System.out.println("üëë".repeat(80));
                
                // üéØ ESTADO DE MEMORIAS INDIVIDUALES
                System.out.println("\nüß† ESTADO DE MEMORIAS INDIVIDUALES:");
                memoria.obtenerTodosLosPiratas().forEach(pirata -> {
                    MemoriaPirata mem = memoria.obtenerMemoriaPirata(pirata).orElse(null);
                    if (mem != null) {
                        System.out.printf("  ‚Ä¢ %-20s: %d recuerdos, %d relaciones, %d habilidades%n",
                            pirata, mem.getRecuerdos().size(), mem.getRelaciones().size(), mem.getHabilidades().size());
                        
                        // üéØ MEJOR AMIGO
                        mem.obtenerMejorAmigo().ifPresent(amigo -> 
                            System.out.printf("      ü§ù Mejor amigo: %s%n", amigo));
                    }
                });
                
                // üîó RED DE RELACIONES
                System.out.println("\nüîó RED DE RELACIONES DE LA TRIPULACI√ìN:");
                memoria.obtenerRelacionesDestacadas().forEach((relacion, fuerza) -> {
                    System.out.printf("  ‚Ä¢ %s ‚Üî %s (fuerza: %d)%n", 
                        relacion.getPirata1(), relacion.getPirata2(), fuerza);
                });
                
                // üíæ FRAGMENTOS DE C√ìDIGO COMPARTIDOS
                System.out.println("\nüíæ FRAGMENTOS DE C√ìDIGO COMPARTIDOS:");
                memoria.obtenerFragmentosDestacados().forEach(fragmento -> {
                    System.out.printf("  ‚Ä¢ %s: %s%n", 
                        fragmento.getPirataOrigen(), fragmento.getProposito());
                });
            }
            
            public static void mostrarDebateEnTiempoReal(String pregunta, List<String> intervenciones) {
                System.out.println("\n" + "üéôÔ∏è".repeat(80));
                System.out.println("           DEBATE EN TIEMPO REAL - CAPIT√ÅN OBSERVANDO");
                System.out.println("üéôÔ∏è".repeat(80));
                System.out.println("‚ùì PREGUNTA: " + pregunta);
                System.out.println("üìä INTERVENCIONES: " + intervenciones.size());
                
                intervenciones.forEach(intervencion -> {
                    System.out.println("\n" + "üí¨".repeat(40));
                    System.out.println(intervencion);
                    System.out.println("üí¨".repeat(40));
                });
            }
        }


		private SistemaMemoriaPirata memoria;


        // üÜï MODIFICAR EL M√âTODO DE RESPUESTA PARA USAR MEMORIA
        private String simularRespuestaPirata(String pregunta, PirataInfo pirata) {
            try {
                // üéØ OBTENER CONTEXTO DE MEMORIA DEL PIRATA
                String contextoMemoria = memoria.obtenerMemoriaPirata(pirata.getNombrePirata())
                        .map(m -> m.obtenerContextoPersonalizado(pregunta))
                        .orElse("");
                
                // üéØ MEJORAR EL PROMPT CON MEMORIA
                String promptMejorado = construirPromptConMemoria(pregunta, pirata, contextoMemoria);
                
                return oraculo.invocar(promptMejorado, "respuesta_pirata_con_memoria", 0.7);
                
            } catch (Exception e) {
                // Fallback al m√©todo original
                return simularRespuestaPirataOriginal(pregunta, pirata);
            }
    }


        private String simularRespuestaPirataOriginal(String pregunta, PirataInfo pirata) {
            // Reutilizar la l√≥gica del m√©todo principal de TripulacionManager
            try {
                String codigoFuente = obtenerCodigoFuente(pirata.getNombreClase());
                
                String promptPirata = 
                    "Eres la clase " + pirata.getNombreClase() + 
                    " con el rol de " + pirata.getRolPirata() + 
                    " y nombre pirata '" + pirata.getNombrePirata() + "'.\n\n" +
                    "Tu descripci√≥n: " + pirata.getDescripcionRol() + "\n\n" +
                    "Tu c√≥digo fuente es:\n```java\n" + codigoFuente + "\n```\n\n" +
                    "Pregunta: " + pregunta + "\n\n" +
                    "Responde en formato pirata pero t√©cnicamente √∫til.";
                
                OraculoDeLaLibertad oraculo = new OraculoDeLaLibertad();
                return oraculo.invocar(promptPirata, "respuesta_pirata_fallback", 0.7);
                
            } catch (Exception e) {
                return "¬°Arrr! Mis circuitos est√°n nublados. Como " + pirata.getNombrePirata() + 
                       ", no puedo responder ahora. Revisa mis ca√±ones (logs) para m√°s detalles.";
            }
        }


		private String construirPromptConMemoria(String pregunta, PirataInfo pirata, String contextoMemoria) {
		    return String.format(
		        "Pirata: %s (%s)\nContexto: %s\nPregunta: %s\n\nResponde como pirata:",
		        pirata.getNombrePirata(), 
		        pirata.getRolPirata(),
		        contextoMemoria,
		        pregunta
		    );
		}
		
		private String obtenerCodigoFuentePirata(String nombrePirata, String nombreClase) {
		    try {
		        // üéØ ESTRATEGIA 1: USAR SCANNER EXISTENTE
		        if (scanner != null) {
		            // Forzar escaneo si es necesario
		            if (scanner.getClasses().isEmpty()) {
		                bitacora.info("üîç Ejecutando escaneo r√°pido para: " + nombreClase);
		                scanner.scanProjectTurbo("."); // Escanear directorio actual
		            }
		            
		            // Buscar en el classMap del scanner
		            Optional<ClassInfo> classInfo = scanner.getClassByName(nombreClase);
		            if (classInfo.isPresent()) {
		                String sourcePath = classInfo.get().getSourcePath();
		                if (sourcePath != null) {
		                    File archivo = new File(sourcePath);
		                    if (archivo.exists()) {
		                        String codigo = Files.readString(archivo.toPath(), StandardCharsets.UTF_8);
		                        if (!codigo.trim().isEmpty()) {
		                            bitacora.info("‚úÖ C√≥digo encontrado via scanner: " + nombreClase);
		                            return codigo;
		                        }
		                    }
		                }
		            }
		        }
		        
		        // üéØ ESTRATEGIA 2: B√öSQUEDA DIRECTA INTELIGENTE
		        String codigoDirecto = buscarCodigoFuenteDirecto(nombreClase);
		        if (codigoDirecto != null && !codigoDirecto.contains("No se pudo encontrar")) {
		            return codigoDirecto;
		        }
		        
		        // üéØ ESTRATEGIA 3: GENERAR C√ìDIGO BASADO EN ROL
		        return (nombrePirata + nombreClase);
		        
		    } catch (Exception e) {
		        bitacora.error("üí• Error obteniendo c√≥digo para " + nombrePirata + ": " + e.getMessage());
		        return (nombrePirata + nombreClase);
		    }
		}

		/**
		 * üéØ B√öSQUEDA DIRECTA MEJORADA
		 */
		private String buscarCodigoFuenteDirecto(String nombreClase) {
		    // üéØ CONVERTIR NOMBRE DE CLASE A RUTAS POSIBLES
		    String rutaClase = nombreClase.replace('.', '/') + ".java";
		    
		    // üéØ LISTA COMPLETA DE UBICACIONES POSIBLES
		    String[] ubicaciones = {
		        "src/main/java/" + rutaClase,
		        "src/test/java/" + rutaClase, 
		        "main/java/" + rutaClase,
		        "test/java/" + rutaClase,
		        "src/" + rutaClase,
		        "./" + rutaClase,
		        "../" + rutaClase,
		        nombreClase.replace('.', '/') + ".java" // Ruta absoluta desde ra√≠z
		    };
		    
		    for (String ubicacion : ubicaciones) {
		        try {
		            File archivo = new File(ubicacion);
		            if (archivo.exists() && archivo.isFile()) {
		                String contenido = Files.readString(archivo.toPath(), StandardCharsets.UTF_8);
		                if (!contenido.trim().isEmpty()) {
		                    bitacora.info("‚úÖ C√≥digo encontrado en: " + ubicacion);
		                    return contenido;
		                }
		            }
		        } catch (Exception e) {
		            // Continuar con siguiente ubicaci√≥n
		        }
		    }
		    
		    return null;
		}
    }   
}
