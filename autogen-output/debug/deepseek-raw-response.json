{"id":"bcc073e2-501b-4531-96b8-deaf6b5072c8","object":"chat.completion","created":1760957232,"model":"deepseek-chat","choices":[{"index":0,"message":{"role":"assistant","content":"```java\npackage com.novelator.autogen.plan;\n\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.function.Supplier;\n\n/**\n * Clase base generada automáticamente desde el plan.\n * Ejecuta planes de texto autónomos con capacidades de procesamiento asíncrono.\n */\npublic class PlanExecutor {\n    \n    private final ExecutorService executorService;\n    private volatile boolean isRunning;\n    private final Object lock = new Object();\n    \n    /**\n     * Constructor por defecto que inicializa el executor con un pool de hilos fijo.\n     */\n    public PlanExecutor() {\n        this.executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n        this.isRunning = false;\n    }\n    \n    /**\n     * Constructor que permite especificar el número de hilos del pool.\n     * \n     * @param threadPoolSize número de hilos en el pool de ejecución\n     */\n    public PlanExecutor(int threadPoolSize) {\n        this.executorService = Executors.newFixedThreadPool(threadPoolSize);\n        this.isRunning = false;\n    }\n    \n    /**\n     * Ejecuta una tarea de forma asíncrona y retorna un CompletableFuture con el resultado.\n     * \n     * @param <T> tipo del resultado\n     * @param taskSupplier proveedor de la tarea a ejecutar\n     * @return CompletableFuture que contendrá el resultado de la ejecución\n     */\n    public <T> CompletableFuture<T> executeAsync(Supplier<T> taskSupplier) {\n        synchronized (lock) {\n            if (!isRunning) {\n                throw new IllegalStateException(\"PlanExecutor no está en ejecución\");\n            }\n        }\n        \n        return CompletableFuture.supplyAsync(taskSupplier, executorService);\n    }\n    \n    /**\n     * Ejecuta una tarea Runnable de forma asíncrona.\n     * \n     * @param task tarea a ejecutar\n     * @return CompletableFuture que se completará cuando termine la tarea\n     */\n    public CompletableFuture<Void> executeAsync(Runnable task) {\n        synchronized (lock) {\n            if (!isRunning) {\n                throw new IllegalStateException(\"PlanExecutor no está en ejecución\");\n            }\n        }\n        \n        return CompletableFuture.runAsync(task, executorService);\n    }\n    \n    /**\n     * Inicia el PlanExecutor, permitiendo la ejecución de tareas.\n     */\n    public void start() {\n        synchronized (lock) {\n            if (isRunning) {\n                throw new IllegalStateException(\"PlanExecutor ya está en ejecución\");\n            }\n            isRunning = true;\n        }\n    }\n    \n    /**\n     * Detiene el PlanExecutor y libera los recursos del executor service.\n     * No acepta nuevas tareas pero permite completar las existentes.\n     */\n    public void stop() {\n        synchronized (lock) {\n            if (!isRunning) {\n                throw new IllegalStateException(\"PlanExecutor no está en ejecución\");\n            }\n            isRunning = false;\n        }\n        executorService.shutdown();\n    }\n    \n    /**\n     * Detiene inmediatamente el PlanExecutor, interrumpiendo todas las tareas en ejecución.\n     */\n    public void stopImmediately() {\n        synchronized (lock) {\n            if (!isRunning) {\n                throw new IllegalStateException(\"PlanExecutor no está en ejecución\");\n            }\n            isRunning = false;\n        }\n        executorService.shutdownNow();\n    }\n    \n    /**\n     * Verifica si el PlanExecutor está en estado de ejecución.\n     * \n     * @return true si está ejecutando, false en caso contrario\n     */\n    public boolean isRunning() {\n        synchronized (lock) {\n            return isRunning;\n        }\n    }\n    \n    /**\n     * Ejecuta una tarea de procesamiento de texto específica del plan.\n     * \n     * @param textContent contenido de texto a procesar\n     * @return resultado del procesamiento del texto\n     */\n    public String processTextPlan(String textContent) {\n        if (textContent == null || textContent.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"El contenido de texto no puede ser nulo o vacío\");\n        }\n        \n        // Implementación base para procesamiento de texto\n        return \"Procesado: \" + textContent.trim() + \" | Estado: \" + \n               (isRunning ? \"EJECUTANDO\" : \"DETENIDO\");\n    }\n    \n    /**\n     * Ejecuta una tarea de análisis de contenido fallido.\n     * \n     * @param analysisData datos de análisis a procesar\n     * @return mensaje indicando el estado del análisis fallido\n     */\n    public String executeFailedAnalysis(String analysisData) {\n        return \"❌ Análisis fallido procesado: \" + \n               (analysisData != null ? analysisData : \"Sin datos\") + \n               \" | Timestamp: \" + System.currentTimeMillis();\n    }\n}\n```"},"logprobs":null,"finish_reason":"stop"}],"usage":{"prompt_tokens":318,"completion_tokens":1075,"total_tokens":1393,"prompt_tokens_details":{"cached_tokens":64},"prompt_cache_hit_tokens":64,"prompt_cache_miss_tokens":254},"system_fingerprint":"fp_ffc7281d48_prod0820_fp8_kvcache"}