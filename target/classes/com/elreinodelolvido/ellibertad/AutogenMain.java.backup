package com.novelator.autogen;

import com.novelator.autogen.engine.Bitacora;
import com.novelator.autogen.model.ClassInfo;
import com.novelator.autogen.scanner.ProjectScanner;
import com.novelator.autogen.scanner.IntegradorForzado;
import com.novelator.autogen.scanner.ClassMetadata;
import com.novelator.autogen.util.*;
import com.novelator.autogen.api.*;

import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * üè¥‚Äç‚ò†Ô∏è AUTOGEN_MAIN_TURBO ‚Äî ¬°EL CORAZ√ìN DEL BARCO PIRATA M√ÅS √âPICO!
 * ‚ö° Ahora con +1000% de artiller√≠a turbo reci√©n creada!
 */
public class AutogenMain {

    private static final Scanner SCANNER_TURBO = new Scanner(System.in);
    private static final String PROJECT_PATH = "./";
    
    // üìä ESTAD√çSTICAS TURBO MEJORADAS
    private static final AtomicInteger CONTADOR_EJECUCIONES = new AtomicInteger(0);
    private static final AtomicInteger CONTADOR_CLASES_PROCESADAS = new AtomicInteger(0);
    private static final AtomicInteger CONTADOR_KRAKENS = new AtomicInteger(0);
    private static final AtomicInteger CONTADOR_INTEGRACIONES_EXITOSAS = new AtomicInteger(0);
    
    // üöÄ COMPONENTES TURBO NUEVOS
    private static final Bitacora BITACORA_TURBO = new Bitacora();
    private static final IntegradorForzado INTEGRADOR_TURBO = new IntegradorForzado(BITACORA_TURBO);
    private static final ProjectScanner SCANNER_AVANZADO = new ProjectScanner(BITACORA_TURBO);

    public static void main(String[] args) {
        System.out.println(getBannerEpico());
        BITACORA_TURBO.info("üöÄ INICIANDO AUTOGEN TURBO CON ARTILLER√çA COMPLETA");
        
        // üöÄ INICIALIZACI√ìN TURBO MEJORADA
        inicializarSistemaTurbo();
        BitacoraConsola.iniciarCaptura();

        try {
            ejecutarCicloPrincipalTurbo();
        } finally {
            BitacoraConsola.restaurarSalida();
            SCANNER_TURBO.close();
            mostrarEstadisticasFinalesEpicas();
            BITACORA_TURBO.info("üèÅ AUTOGEN TURBO FINALIZADO");
        }
    }

    /**
     * üöÄ INICIALIZACI√ìN TURBO COMPLETA
     */
    private static void inicializarSistemaTurbo() {
        BITACORA_TURBO.turbo("Inicializando artiller√≠a turbo...");
        
        FileUtils.crearArchivoSiNoExiste("autogen-output/objetivos.md", "# Objetivos de la traves√≠a\n\n- ");
        FileUtils.crearArchivoSiNoExiste("autogen-output/bitacora-pirata.md", "# Bit√°cora del Nav√≠o Libertad\n\n");
        
        // Configurar bit√°cora turbo
        Bitacora.setNivelMinimo(Bitacora.Nivel.INFO);
        Bitacora.setConsolaActiva(true);
        Bitacora.setArchivoActivo(true);
        
        BITACORA_TURBO.exito("Sistema turbo inicializado correctamente");
    }

    /**
     * üöÄ CICLO PRINCIPAL TURBO MEJORADO
     */
    private static void ejecutarCicloPrincipalTurbo() {
        while (true) {
            CONTADOR_EJECUCIONES.incrementAndGet();
            BITACORA_TURBO.info("‚öì SESI√ìN PIRATA #" + CONTADOR_EJECUCIONES.get());
            
            mostrarMenuPrincipalTurbo();
            String opcion = SCANNER_TURBO.nextLine().trim();
            
            if (!procesarOpcionTurbo(opcion)) {
                break;
            }
            
            if (!preguntarVolverAlMenu()) {
                BITACORA_TURBO.info("üëã Cerrando AUTOGEN. ¬°Hasta la pr√≥xima, Capit√°n!");
                break;
            }
        }
    }

    /**
     * üéØ PROCESAMIENTO TURBO DE OPCIONES MEJORADO - COMPLETO
     */
    private static boolean procesarOpcionTurbo(String opcion) {
        long startTime = System.currentTimeMillis();
        BITACORA_TURBO.debug("Procesando opci√≥n: " + opcion);
        
        try {
            switch (opcion.toLowerCase()) {
                case "1": 
                    BITACORA_TURBO.turbo("ACTIVANDO AN√ÅLISIS INTERACTIVO TURBO...");
                    ejecutarAnalisisCompleto(false);
                    break;
                case "2": 
                    BITACORA_TURBO.turbo("ACTIVANDO DRY-RUN TURBO...");
                    ejecutarAnalisisCompleto(true);
                    break;
                case "3": 
                    BITACORA_TURBO.turbo("ACTIVANDO ROLLBACK TURBO...");
                    ejecutarRollbackCompleto();
                    break;
                case "4": 
                    BITACORA_TURBO.turbo("ACTIVANDO ACTUALIZACI√ìN COMPLETA TURBO...");
                    ejecutarActualizacionTurboCompleta();
                    break;
                case "5": 
                    BITACORA_TURBO.turbo("ACTIVANDO NARRATIVA TURBO...");
                    generarInformesCompletos();
                    break;
                case "6": 
                    BITACORA_TURBO.turbo("ACTIVANDO CONSOLA DE TRIPULACI√ìN TURBO...");
                    ConsolaDeTripulacion.iniciarDialogoInteractivo();
                    break;
                case "7":
                    BITACORA_TURBO.turbo("ACTIVANDO ESC√ÅNER AVANZADO TURBO...");
                    ejecutarEscaneoAvanzado();
                    break;
                case "8":
                    BITACORA_TURBO.turbo("ACTIVANDO AN√ÅLISIS DE METADATAS...");
                    ejecutarAnalisisMetadatas();
                    break;
                case "9":
                    BITACORA_TURBO.turbo("ACTIVANDO INTEGRACI√ìN FORZADA TURBO...");
                    ejecutarIntegracionForzada();
                    break;
                case "10":
                    BITACORA_TURBO.turbo("ACTIVANDO DIAGN√ìSTICO COMPLETO...");
                    ejecutarDiagnosticoCompleto();
                    break;
                case "f": 
                    BITACORA_TURBO.turbo("ACTIVANDO OR√ÅCULO TURBO...");
                    TripulanteOraculo.iniciarConsolaLibre();
                    break;
                case "debug": 
                    mostrarDebugTurboCompleto();
                    break;
                case "stats":
                    mostrarEstadisticasAvanzadas();
                    break;
                case "cache":
                    mostrarEstadoCache();
                    break;
                case "reparar":
                    BITACORA_TURBO.turbo("ACTIVANDO REPARACI√ìN DE EMERGENCIA...");
                    ejecutarReparacionEmergencia();
                    break;
                case "formatos":
                    BITACORA_TURBO.turbo("ACTIVANDO REPARACI√ìN DE FORMATOS...");
                    ejecutarReparacionFormatos();
                    break;
                case "diag-formatos":
                    BITACORA_TURBO.turbo("ACTIVANDO DIAGN√ìSTICO DE FORMATOS...");
                    ejecutarDiagnosticoFormatos();
                    break;
                case "0": 
                    BITACORA_TURBO.info("üëã Saliendo de AUTOGEN. ¬°Hasta pronto, Capit√°n!");
                    return false;
                default:
                    BITACORA_TURBO.error("Opci√≥n inv√°lida: " + opcion);
                    System.out.println("‚ùå Opci√≥n inv√°lida. Int√©ntalo de nuevo, grumete.");
            }
            
            long tiempo = System.currentTimeMillis() - startTime;
            BITACORA_TURBO.info("‚è±Ô∏è Operaci√≥n completada en " + tiempo + "ms");
            
        } catch (Exception e) {
            CONTADOR_KRAKENS.incrementAndGet();
            BITACORA_TURBO.error("üí• KRAKEN DETECTADO en procesarOpcionTurbo", e);
            FileUtils.registrarKraken("AutogenMain", getStackTrace(e));
        }
        
        return true;
    }

    /**
     * üé™ MEN√ö PRINCIPAL TURBO-√âPICO MEJORADO
     */
    /**
     * üé™ MEN√ö PRINCIPAL TURBO-√âPICO MEJORADO
     */
    private static void mostrarMenuPrincipalTurbo() {
        System.out.println("\n" + "‚öì".repeat(60));
        System.out.println("üè¥‚Äç‚ò†Ô∏è  AUTOGEN TURBO ARTILLER√çA COMPLETA - MEN√ö DEL CAPIT√ÅN");
        System.out.println("‚öì".repeat(60));
        System.out.println("1Ô∏è‚É£  ‚ö° An√°lisis y revisi√≥n interactiva TURBO");
        System.out.println("2Ô∏è‚É£  üé≠ An√°lisis en modo DRY-RUN TURBO");
        System.out.println("3Ô∏è‚É£  ‚è™ Rollback turbo completo");
        System.out.println("4Ô∏è‚É£  üî• ACTUALIZACI√ìN COMPLETA TURBO");
        System.out.println("5Ô∏è‚É£  üìú Informes completos y narrativa");
        System.out.println("6Ô∏è‚É£  üó£Ô∏è  Consola de tripulaci√≥n TURBO");
        System.out.println("7Ô∏è‚É£  üîç Esc√°ner avanzado TURBO");
        System.out.println("8Ô∏è‚É£  üìä An√°lisis de metadatas");
        System.out.println("9Ô∏è‚É£  üöÄ Integraci√≥n forzada TURBO");
        System.out.println("üîü  ü©∫ Diagn√≥stico completo del sistema");
        System.out.println("FÔ∏è‚É£  üîÆ Or√°culo turbo (consola libre)");
        System.out.println("‚öì".repeat(60));
        System.out.println("üíæ debug - Modo diagn√≥stico completo");
        System.out.println("üìà stats - Estad√≠sticas avanzadas");
        System.out.println("üóÇÔ∏è  cache - Estado de cache");
        System.out.println("üîß reparar - Reparaci√≥n de emergencia del scanner");
        System.out.println("üîß formatos - Reparaci√≥n de formatos problem√°ticos"); // ‚Üê A√ëADIR ESTA L√çNEA
        System.out.println("0Ô∏è‚É£  üö™ Salir del barco");
        System.out.println("‚öì".repeat(60));
        System.out.print("üéØ ¬øCu√°l es tu orden, Capit√°n?: ");
    }

    /**
     * üî• ACTUALIZACI√ìN COMPLETA TURBO MEJORADA
     */
    private static void ejecutarActualizacionTurboCompleta() {
        BITACORA_TURBO.info("üî• INICIANDO ACTUALIZACI√ìN COMPLETA TURBO CON ARTILLER√çA NUEVA");
        System.out.println("\n" + "üî•".repeat(70));
        System.out.println("           ACTIVANDO ACTUALIZACI√ìN COMPLETA TURBO - ARTILLER√çA DESPLEGADA");
        System.out.println("üî•".repeat(70));

        // üéØ PASO 1: ESCANEO AVANZADO
        BITACORA_TURBO.info("üìå PASO 1: ESCANEO AVANZADO TURBO");
        ejecutarConRescate(() -> {
            SCANNER_AVANZADO.scanProject(PROJECT_PATH);
            BITACORA_TURBO.exito("Escaneo avanzado completado: " + SCANNER_AVANZADO.getClasses().size() + " clases");
        }, "ProjectScanner Avanzado");

        // üéØ PASO 2: OBJETIVOS TURBO
        BITACORA_TURBO.info("üìå PASO 2: OBJETIVOS DE LA TRAVES√çA");
        String objetivos = capturarObjetivosTurbo();
        FileUtils.writeToFile("autogen-output/objetivos.md", objetivos);
        BITACORA_TURBO.exito("Objetivos turbo-guardados: " + objetivos.split("\n").length + " objetivos");

        // üéØ PASO 3: AN√ÅLISIS DE METADATAS
        BITACORA_TURBO.info("üìå PASO 3: AN√ÅLISIS DE METADATAS AVANZADO");
        ejecutarAnalisisMetadatas();

        // üéØ PASO 4: GENERACI√ìN DE PLAN
        BITACORA_TURBO.info("üìå PASO 4: PLAN ESTRAT√âGICO TURBO");
        ejecutarConRescate(() -> {
            String resumenPirata = ResumenProyecto.generarResumenPirata();
            GeneradorPlanDesdeObjetivos.generar(resumenPirata, objetivos);
            BITACORA_TURBO.exito("Plan estrat√©gico turbo-generado");
        }, "GeneradorPlanDesdeObjetivos");

        // üéØ PASO 5: PIPELINE DE AN√ÅLISIS TURBO MEJORADO
        BITACORA_TURBO.info("üìå PASO 5: PIPELINE DE AN√ÅLISIS TURBO MEJORADO");
        ejecutarAnalisisCompleto(false);

        // üéØ PASO 6: INTEGRACI√ìN FORZADA
        BITACORA_TURBO.info("üìå PASO 6: INTEGRACI√ìN FORZADA TURBO");
        ejecutarIntegracionForzada();

        // üéØ PASO 7: DIAGN√ìSTICO FINAL
        BITACORA_TURBO.info("üìå PASO 7: DIAGN√ìSTICO FINAL TURBO");
        ejecutarDiagnosticoCompleto();

        BITACORA_TURBO.exito("üéä ACTUALIZACI√ìN COMPLETA TURBO FINALIZADA CON √âXITO");
        System.out.println("\nüöÄ El barco 'Libertad' navega m√°s r√°pido que nunca con artiller√≠a completa!");
    }

    /**
     * üîç ESCANEO AVANZADO TURBO
     */
    private static void ejecutarEscaneoAvanzado() {
        BITACORA_TURBO.info("üîç INICIANDO ESCANEO AVANZADO TURBO...");
        
        ejecutarConRescate(() -> {
            SCANNER_AVANZADO.scanProject(PROJECT_PATH);
            
            // Mostrar estad√≠sticas detalladas
            Map<String, Integer> stats = SCANNER_AVANZADO.getStatistics();
            BITACORA_TURBO.info("üìä ESTAD√çSTICAS DE ESCANEO AVANZADO:");
            stats.forEach((key, value) -> {
                BITACORA_TURBO.info("  ‚Ä¢ " + key + ": " + value);
            });
            
            // Mostrar resumen de clases
            System.out.println("\n" + "üì¶".repeat(50));
            System.out.println("           RESUMEN DE CLASES DETECTADAS");
            System.out.println("üì¶".repeat(50));
            
            SCANNER_AVANZADO.getClasses().forEach(clazz -> {
                System.out.println("üéØ " + clazz.toShortString());
            });
            
            BITACORA_TURBO.exito("Escaneo avanzado completado");
            
        }, "Escaneo Avanzado");
    }

    /**
     * üìä AN√ÅLISIS DE METADATAS
     */
    private static void ejecutarAnalisisMetadatas() {
        BITACORA_TURBO.info("üìä INICIANDO AN√ÅLISIS DE METADATAS...");
        
        ejecutarConRescate(() -> {
            List<ClassMetadata> metadatas = SCANNER_AVANZADO.getClassMetadata();
            
            BITACORA_TURBO.info("üìà ANALIZANDO " + metadatas.size() + " CLASES CON METADATAS");
            
            // Clases que necesitan refactorizaci√≥n urgente
            List<ClassMetadata> urgentes = metadatas.stream()
                .filter(ClassMetadata::isHighPriority)
                .toList();
                
            if (!urgentes.isEmpty()) {
                BITACORA_TURBO.info("üö® CLASES QUE NECESITAN REFACTORIZACI√ìN URGENTE:");
                urgentes.forEach(metadata -> {
                    BITACORA_TURBO.info("  ‚ö†Ô∏è " + metadata.getFullyQualifiedName() + 
                                      " - " + metadata.getCodeSmells().size() + " smells");
                });
            }
            
            // Estad√≠sticas de calidad
            long clasesConProblemas = metadatas.stream()
                .filter(ClassMetadata::isNeedsRefactoring)
                .count();
                
            double tasaProblemas = (double) clasesConProblemas / metadatas.size() * 100;
            
            BITACORA_TURBO.info("üìã RESUMEN DE CALIDAD:");
            BITACORA_TURBO.info("  ‚Ä¢ Total clases analizadas: " + metadatas.size());
            BITACORA_TURBO.info("  ‚Ä¢ Clases con problemas: " + clasesConProblemas);
            BITACORA_TURBO.info("  ‚Ä¢ Tasa de problemas: " + String.format("%.1f%%", tasaProblemas));
            BITACORA_TURBO.info("  ‚Ä¢ Clases de alta prioridad: " + urgentes.size());
            
            // Guardar reporte detallado
            StringBuilder reporte = new StringBuilder();
            reporte.append("# üìä REPORTE DE METADATAS - AN√ÅLISIS DE CALIDAD\n\n");
            
            metadatas.forEach(metadata -> {
                reporte.append(metadata.toDetailedString()).append("\n\n");
            });
            
            FileUtils.writeToFile("autogen-output/analisis/metadatas-detallado.md", reporte.toString());
            BITACORA_TURBO.exito("An√°lisis de metadatas completado y guardado");
            
        }, "An√°lisis de Metadatas");
    }

    /**
     * üöÄ INTEGRACI√ìN FORZADA TURBO
     */
    private static void ejecutarIntegracionForzada() {
        BITACORA_TURBO.info("üöÄ INICIANDO INTEGRACI√ìN FORZADA TURBO...");
        
        // En un escenario real, aqu√≠ procesar√≠as los archivos refactorizados
        // Por ahora simulamos una integraci√≥n de ejemplo
        
        ejecutarConRescate(() -> {
            BITACORA_TURBO.info("üîß PREPARANDO INTEGRACI√ìN FORZADA...");
            
            // Simular algunos archivos para integraci√≥n
            List<Object> archivosGenerados = new ArrayList<>();
            List<Object> archivosDestino = new ArrayList<>();
            
            // En producci√≥n, aqu√≠ cargar√≠as los archivos reales del directorio refactor
            if (archivosGenerados.isEmpty()) {
                BITACORA_TURBO.info("üìù Modo demostraci√≥n: mostrando capacidades de integraci√≥n");
                
                // Mostrar estad√≠sticas del integrador
                IntegradorForzado.EstadisticasIntegracion stats = INTEGRADOR_TURBO.getEstadisticas();
                BITACORA_TURBO.info("üìà " + stats.toString());
                
                BITACORA_TURBO.exito("Sistema de integraci√≥n forzada listo y operativo");
                return;
            }
            
            // Ejecutar integraci√≥n por lotes
            IntegradorForzado.ResultadoLote resultado = INTEGRADOR_TURBO.integrarTodos(archivosGenerados, archivosDestino);
            
            BITACORA_TURBO.info("üéØ RESULTADO INTEGRACI√ìN: " + resultado.toString());
            
            if (!resultado.getFallados().isEmpty()) {
                BITACORA_TURBO.error("‚ùå Archivos con errores en integraci√≥n:");
                resultado.getFallados().forEach(archivo -> {
                    BITACORA_TURBO.error("  ‚Ä¢ " + archivo.getFileName());
                });
            }
            
            CONTADOR_INTEGRACIONES_EXITOSAS.addAndGet(resultado.getExitos());
            BITACORA_TURBO.exito("Integraci√≥n forzada completada");
            
        }, "Integraci√≥n Forzada");
    }

    /**
     * ü©∫ DIAGN√ìSTICO COMPLETO DEL SISTEMA
     */
    private static void ejecutarDiagnosticoCompleto() {
        BITACORA_TURBO.info("ü©∫ INICIANDO DIAGN√ìSTICO COMPLETO DEL SISTEMA...");
        
        System.out.println("\n" + "üîç".repeat(60));
        System.out.println("           DIAGN√ìSTICO COMPLETO - SISTEMA AUTOGEN TURBO");
        System.out.println("üîç".repeat(60));
        
        // 1. Estado del esc√°ner
        ejecutarConRescate(() -> {
            Map<String, Integer> statsScanner = SCANNER_AVANZADO.getStatistics();
            System.out.println("\nüìä ESTADO DEL ESC√ÅNER:");
            statsScanner.forEach((key, value) -> {
                System.out.println("  ‚úÖ " + key + ": " + value);
            });
        }, "Diagn√≥stico Esc√°ner");
        
        // 2. Estado de la bit√°cora
        ejecutarConRescate(() -> {
            System.out.println("\nüìù ESTADO DE LA BIT√ÅCORA:");
            System.out.println("  ‚úÖ Eventos en memoria: " + BITACORA_TURBO.getTotalEventos());
            System.out.println("  ‚úÖ Nivel m√≠nimo: " + Bitacora.Nivel.INFO);
            System.out.println(BITACORA_TURBO.generarReporte());
        }, "Diagn√≥stico Bit√°cora");
        
        // 3. Estado del integrador
        ejecutarConRescate(() -> {
            IntegradorForzado.EstadisticasIntegracion statsIntegrador = INTEGRADOR_TURBO.getEstadisticas();
            System.out.println("\nüöÄ ESTADO DEL INTEGRADOR:");
            System.out.println("  ‚úÖ " + statsIntegrador.toString());
        }, "Diagn√≥stico Integrador");
        
        // 4. Estado general del sistema
        System.out.println("\nüéØ ESTADO GENERAL DEL SISTEMA:");
        System.out.println("  ‚úÖ Ejecuciones: " + CONTADOR_EJECUCIONES.get());
        System.out.println("  ‚úÖ Clases procesadas: " + CONTADOR_CLASES_PROCESADAS.get());
        System.out.println("  ‚úÖ Integraciones exitosas: " + CONTADOR_INTEGRACIONES_EXITOSAS.get());
        System.out.println("  ‚úÖ Krakens derrotados: " + CONTADOR_KRAKENS.get());
        System.out.println("  ‚úÖ Eficiencia: " + 
            String.format("%.1f%%", (1 - (double)CONTADOR_KRAKENS.get() / CONTADOR_CLASES_PROCESADAS.get()) * 100));
        
        BITACORA_TURBO.exito("Diagn√≥stico completo finalizado");
    }

    /**
     * üîß AN√ÅLISIS COMPLETO TURBO MEJORADO
     */
    private static void ejecutarAnalisisCompleto(boolean modoDryRun) {
        BITACORA_TURBO.info("üîç INICIANDO AN√ÅLISIS COMPLETO TURBO...");
        
        ejecutarConRescate(() -> {
            // Usar el scanner avanzado
            SCANNER_AVANZADO.scanProject(PROJECT_PATH);
            List<ClassInfo> classes = SCANNER_AVANZADO.getClasses();
            
            BITACORA_TURBO.info("üéØ " + classes.size() + " clases detectadas para an√°lisis avanzado");

            OraculoTecnico oraculo = new OraculoTecnico(null, null, 0);
            List<ResumenDryRun> resumenDryRun = new ArrayList<>();

            for (ClassInfo clazz : classes) {
                CONTADOR_CLASES_PROCESADAS.incrementAndGet();
                procesarClaseTurboAvanzada(clazz, oraculo, resumenDryRun, modoDryRun);
            }

            PlanificadorRefactor.guardarPlan();
            
            if (modoDryRun) {
                mostrarResumenDryRunTurbo(resumenDryRun);
            }

            BITACORA_TURBO.exito("An√°lisis completo turbo finalizado");
            
        }, "An√°lisis Completo");
    }

	/**
     * ‚ö° PROCESAMIENTO DE CLASE TURBO AVANZADA
     */
    /**
     * ‚ö° PROCESAMIENTO DE CLASE TURBO AVANZADA - CORREGIDO
     */
    private static void procesarClaseTurboAvanzada(ClassInfo clazz, OraculoTecnico oraculo, 
            List<ResumenDryRun> resumenDryRun, boolean modoDryRun) {
        try {
            BITACORA_TURBO.debug("üîß Procesando clase avanzada: " + clazz.getFullName());

            String codigoOriginal = FileUtils.readFile(clazz.getSourcePath());
            
            // üéØ VALIDACI√ìN SEGURA DEL FORMATO
            if (codigoOriginal == null || codigoOriginal.trim().isEmpty()) {
                BITACORA_TURBO.warn("‚ö†Ô∏è C√≥digo original vac√≠o o nulo para: " + clazz.getName());
                return;
            }

            String respuestaLLM = oraculo.invocarTecnico(codigoOriginal);

            if (respuestaLLM != null) {
                // üéØ VALIDAR que el c√≥digo generado es √∫til
                if (!FileUtils.esCodigoJavaValido(respuestaLLM)) {
                    BITACORA_TURBO.warn("‚ö†Ô∏è C√≥digo generado inv√°lido para: " + clazz.getName());
                    respuestaLLM = "// ‚ùå ERROR: No se gener√≥ c√≥digo v√°lido para " + clazz.getName();
                }

                generarArtefactosTurboAvanzados(clazz, respuestaLLM, codigoOriginal, resumenDryRun, modoDryRun);
            }

        } catch (UnknownFormatConversionException formatEx) {
            // üéØ CAPTURA ESPEC√çFICA DEL ERROR DE FORMATO
            CONTADOR_KRAKENS.incrementAndGet();
            BITACORA_TURBO.error("üí• ERROR DE FORMATO en clase: " + clazz.getName() + " - " + formatEx.getMessage());
            
            // üîß REGISTRO DETALLADO PARA DIAGN√ìSTICO
            String diagnostico = String.format(
                "üêô KRAKEN DE FORMATO - Clase: %s, Error: %s",
                clazz.getName(),
                formatEx.getMessage()
            );
            FileUtils.registrarKraken("FormatoError_" + clazz.getName(), diagnostico);
            
        } catch (Exception e) {
            CONTADOR_KRAKENS.incrementAndGet();
            BITACORA_TURBO.error("üí• Error gen√©rico en clase avanzada: " + clazz.getName(), e);
            FileUtils.registrarKraken(clazz.getName(), getStackTrace(e));
        }
    }

    /**
     * üé™ GENERACI√ìN DE ARTEFACTOS TURBO AVANZADOS
     */
    private static void generarArtefactosTurboAvanzados(ClassInfo clazz, String respuestaLLM, String codigoOriginal,
                                                       List<ResumenDryRun> resumenDryRun, boolean modoDryRun) {
        String packagePath = clazz.getPackageName().replace('.', '/');
        String basePath = "autogen-output/clases/" + packagePath + "/" + clazz.getName();
        String refactorPath = "autogen-output/refactor/" + packagePath + "/" + clazz.getName();

        // üìÅ GUARDAR ARTEFACTOS TURBO AVANZADOS
        FileUtils.writeToFile(basePath + ".java", codigoOriginal);
        FileUtils.writeToFile(refactorPath + ".gpt.json", respuestaLLM);

        String codigoRefactor = FileUtils.extraerBloqueDeCodigo(respuestaLLM);
        FileUtils.writeToFile(refactorPath + ".refactor.java", codigoRefactor);

        String diff = DiffUtil.generarDiff(clazz.getSourcePath(), refactorPath + ".refactor.java");
        FileUtils.writeToFile(refactorPath + ".diff.txt", diff);

        String validacionFirmas = ValidadorFirmas.validarFirmas(clazz.getSourcePath(), refactorPath + ".refactor.java");
        FileUtils.writeToFile(refactorPath + ".check.txt", validacionFirmas);

        // üìä REGISTRO TURBO AVANZADO
        String resumen = codigoRefactor.length() > 120 ? 
            codigoRefactor.substring(0, 120) + "..." : codigoRefactor.replaceAll("\n", " ");
        PlanificadorRefactor.registrar(clazz.getName(), clazz.getPackageName(), resumen);

        if (modoDryRun) {
            boolean firmasOk = validacionFirmas.contains("‚úÖ");
            resumenDryRun.add(new ResumenDryRun(clazz.getName(), clazz.getPackageName(), firmasOk, resumen));
        } else {
            RevisorInteractivo.revisar(clazz);
        }
        
        BITACORA_TURBO.debug("‚úÖ Artefactos generados para: " + clazz.getFullName());
    }

    /**
     * ‚è™ ROLLBACK COMPLETO TURBO
     */
    private static void ejecutarRollbackCompleto() {
        BITACORA_TURBO.info("‚è™ INICIANDO ROLLBACK COMPLETO TURBO...");
        
        ejecutarConRescate(() -> {
            RollbackManager.ejecutarRollback(PROJECT_PATH);
            BITACORA_TURBO.exito("Rollback completo ejecutado");
        }, "Rollback Completo");
    }

    /**
     * üìú GENERACI√ìN DE INFORMES COMPLETOS
     */
    private static void generarInformesCompletos() {
        BITACORA_TURBO.info("üìú GENERANDO INFORMES COMPLETOS TURBO...");
        
        ejecutarConRescate(() -> {
            String informe = KrakensAnalyzer.generarInforme();
            FileUtils.writeToFile("autogen-output/krakens/log-krakens.md", informe);
            BITACORA_TURBO.exito("Informe de krakens turbo-generado");
        }, "Generador Informe Krakens");

        ejecutarConRescate(() -> {
            String historia = NarradorPirata.generarNarrativaFinal();
            FileUtils.appendToFile("autogen-output/bitacora-pirata.md", historia);
            BITACORA_TURBO.exito("Historia pirata turbo-generada");
        }, "Narrador Pirata");

        // Nuevo: Reporte de m√©tricas avanzadas
        ejecutarConRescate(() -> {
            String reporteMetricas = generarReporteMetricasAvanzado();
            FileUtils.writeToFile("autogen-output/analisis/metricas-avanzadas.md", reporteMetricas);
            BITACORA_TURBO.exito("Reporte de m√©tricas avanzadas generado");
        }, "Generador M√©tricas Avanzadas");
    }

    /**
     * üé™ DEBUG TURBO COMPLETO
     */
    private static void mostrarDebugTurboCompleto() {
        BITACORA_TURBO.info("üîß EJECUTANDO DEBUG TURBO COMPLETO...");
        
        System.out.println("\n" + "üîß".repeat(60));
        System.out.println("           DEBUG TURBO COMPLETO - ARTILLER√çA COMPLETA");
        System.out.println("üîß".repeat(60));
        
        System.out.println("üìÅ PROJECT_PATH: " + PROJECT_PATH);
        System.out.println("‚ö° Ejecuciones: " + CONTADOR_EJECUCIONES.get());
        System.out.println("üîß Clases procesadas: " + CONTADOR_CLASES_PROCESADAS.get());
        System.out.println("üöÄ Integraciones exitosas: " + CONTADOR_INTEGRACIONES_EXITOSAS.get());
        System.out.println("üí• Krakens: " + CONTADOR_KRAKENS.get());
        System.out.println("üìù Bit√°cora eventos: " + BITACORA_TURBO.getTotalEventos());
        
        // Estado del scanner
        Map<String, Integer> stats = SCANNER_AVANZADO.getStatistics();
        System.out.println("üîç Scanner - Clases: " + stats.get("total_classes"));
        System.out.println("üîç Scanner - Errores: " + stats.get("scan_errors"));
        
        // Estado del integrador
        IntegradorForzado.EstadisticasIntegracion statsInt = INTEGRADOR_TURBO.getEstadisticas();
        System.out.println("üöÄ Integrador - Tasa √©xito: " + String.format("%.1f%%", statsInt.getTasaExito() * 100));
        
        System.out.println("üîß".repeat(60));
    }

    /**
     * üìà ESTAD√çSTICAS AVANZADAS
     */
    private static void mostrarEstadisticasAvanzadas() {
        BITACORA_TURBO.info("üìà MOSTRANDO ESTAD√çSTICAS AVANZADAS...");
        
        System.out.println("\n" + "üìä".repeat(60));
        System.out.println("           ESTAD√çSTICAS AVANZADAS - SISTEMA TURBO");
        System.out.println("üìä".repeat(60));
        
        double eficiencia = CONTADOR_CLASES_PROCESADAS.get() > 0 ? 
            (1 - (double)CONTADOR_KRAKENS.get() / CONTADOR_CLASES_PROCESADAS.get()) * 100 : 0;
        
        System.out.println("üéØ M√âTRICAS DE OPERACI√ìN:");
        System.out.println("  ‚Ä¢ Sesiones completadas: " + CONTADOR_EJECUCIONES.get());
        System.out.println("  ‚Ä¢ Clases procesadas: " + CONTADOR_CLASES_PROCESADAS.get());
        System.out.println("  ‚Ä¢ Integraciones exitosas: " + CONTADOR_INTEGRACIONES_EXITOSAS.get());
        System.out.println("  ‚Ä¢ Krakens encontrados: " + CONTADOR_KRAKENS.get());
        System.out.println("  ‚Ä¢ Eficiencia del sistema: " + String.format("%.1f%%", eficiencia));
        
        System.out.println("\nüîç M√âTRICAS DE ESCANEO:");
        Map<String, Integer> stats = SCANNER_AVANZADO.getStatistics();
        stats.forEach((key, value) -> {
            System.out.println("  ‚Ä¢ " + key + ": " + value);
        });
        
        System.out.println("\nüìù M√âTRICAS DE BIT√ÅCORA:");
        System.out.println("  ‚Ä¢ Total eventos: " + BITACORA_TURBO.getTotalEventos());
        Map<Bitacora.Nivel, Integer> statsBitacora = BITACORA_TURBO.getEstadisticasNiveles();
        statsBitacora.forEach((nivel, count) -> {
            if (count > 0) {
                System.out.println("  ‚Ä¢ " + nivel.getTexto() + ": " + count);
            }
        });
        
        System.out.println("üìä".repeat(60));
    }

    /**
     * üóÇÔ∏è ESTADO DE CACHE
     */
    private static void mostrarEstadoCache() {
        BITACORA_TURBO.info("üóÇÔ∏è MOSTRANDO ESTADO DE CACHE...");
        
        // Esto ser√≠a implementado cuando tengas el PromptCache en uso
        System.out.println("\nüóÇÔ∏è  Estado de Cache - EN DESARROLLO");
        System.out.println("üîÆ El sistema de cache estar√° disponible en la pr√≥xima actualizaci√≥n");
        System.out.println("üí° Funci√≥n planificada para: Cache de prompts y respuestas LLM");
    }

    /**
     * üìã GENERAR REPORTE DE M√âTRICAS AVANZADO
     */
    private static String generarReporteMetricasAvanzado() {
        StringBuilder reporte = new StringBuilder();
        reporte.append("# üìä REPORTE DE M√âTRICAS AVANZADAS - AUTOGEN TURBO\n\n");
        
        reporte.append("## üéØ M√âTRICAS DE OPERACI√ìN\n");
        reporte.append("- Sesiones completadas: ").append(CONTADOR_EJECUCIONES.get()).append("\n");
        reporte.append("- Clases procesadas: ").append(CONTADOR_CLASES_PROCESADAS.get()).append("\n");
        reporte.append("- Integraciones exitosas: ").append(CONTADOR_INTEGRACIONES_EXITOSAS.get()).append("\n");
        reporte.append("- Krakens derrotados: ").append(CONTADOR_KRAKENS.get()).append("\n");
        
        double eficiencia = CONTADOR_CLASES_PROCESADAS.get() > 0 ? 
            (1 - (double)CONTADOR_KRAKENS.get() / CONTADOR_CLASES_PROCESADAS.get()) * 100 : 0;
        reporte.append("- Eficiencia del sistema: ").append(String.format("%.1f%%", eficiencia)).append("\n\n");
        
        reporte.append("## üîç ESTADO DEL ESC√ÅNER\n");
        Map<String, Integer> stats = SCANNER_AVANZADO.getStatistics();
        stats.forEach((key, value) -> {
            reporte.append("- ").append(key).append(": ").append(value).append("\n");
        });
        
        reporte.append("\n## üìù ACTIVIDAD DE LA BIT√ÅCORA\n");
        reporte.append(BITACORA_TURBO.generarReporte());
        
        return reporte.toString();
    }

    // üîß M√âTODOS EXISTENTES (modificados para usar la nueva artiller√≠a)
    
    private static String capturarObjetivosTurbo() {
        StringBuilder objetivos = new StringBuilder();
        BITACORA_TURBO.info("üéØ Capturando objetivos de la traves√≠a...");
        
        System.out.println("üéØ Escribe tus objetivos (l√≠nea vac√≠a para terminar):");
        
        String linea;
        int contadorLineas = 0;
        while (!(linea = SCANNER_TURBO.nextLine()).equals("")) {
            objetivos.append("- ").append(linea).append("\n");
            contadorLineas++;
            BITACORA_TURBO.debug("L√≠nea " + contadorLineas + " capturada...");
        }
        
        BITACORA_TURBO.exito(contadorLineas + " objetivos capturados");
        return objetivos.toString();
    }

    private static boolean preguntarVolverAlMenu() {
        System.out.print("\nüîÅ ¬øContinuar en el puente de mando? (s/N): ");
        String respuesta = SCANNER_TURBO.nextLine().trim().toLowerCase();
        return respuesta.equals("s") || respuesta.equals("s√≠") || respuesta.equals("si") || respuesta.equals("y");
    }

    private static void mostrarEstadisticasFinalesEpicas() {
        BITACORA_TURBO.info("üèÅ MOSTRANDO ESTAD√çSTICAS FINALES √âPICAS");
        
        System.out.println("\n" + "üéä".repeat(60));
        System.out.println("           ESTAD√çSTICAS FINALES TURBO - ARTILLER√çA COMPLETA");
        System.out.println("üéä".repeat(60));
        System.out.println("‚ö° Sesiones completadas: " + CONTADOR_EJECUCIONES.get());
        System.out.println("üîß Clases procesadas: " + CONTADOR_CLASES_PROCESADAS.get());
        System.out.println("üöÄ Integraciones exitosas: " + CONTADOR_INTEGRACIONES_EXITOSAS.get());
        System.out.println("üí• Krakens derrotados: " + CONTADOR_KRAKENS.get());
        System.out.println("üéØ Tasa de √©xito: " + 
            String.format("%.1f%%", (1 - (double)CONTADOR_KRAKENS.get() / CONTADOR_CLASES_PROCESADAS.get()) * 100));
        System.out.println("üìù Eventos de bit√°cora: " + BITACORA_TURBO.getTotalEventos());
        System.out.println("üè¥‚Äç‚ò†Ô∏è ¬°Hasta la pr√≥xima, Capit√°n!");
        System.out.println("üéä".repeat(60));
    }

    // üîß M√âTODOS DE UTILIDAD (sin cambios)
    
    private static <T> T ejecutarConRescate(SupplierTurbo<T> accion, String nombreModulo, T valorPorDefecto) {
        try {
            return accion.get();
        } catch (Exception e) {
            CONTADOR_KRAKENS.incrementAndGet();
            BITACORA_TURBO.error("üí• KRAKEN en " + nombreModulo, e);
            FileUtils.registrarKraken(nombreModulo, getStackTrace(e));
            return valorPorDefecto;
        }
    }

    private static void ejecutarConRescate(Runnable accion, String nombreModulo) {
        ejecutarConRescate(() -> {
            accion.run();
            return null;
        }, nombreModulo, null);
    }

    private static String getBannerEpico() {
        return """
            
            ‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì
            üè¥‚Äç‚ò†Ô∏è        AUTOGEN TURBO ARTILLER√çA v3.0       üè¥‚Äç‚ò†Ô∏è
            ‚ö°      EL BARCO PIRATA DEL C√ìDIGO - COMPLETO     ‚ö°
            ‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì‚öì
            
            """;
    }

    private static String trunc(String s, int max) {
        return s.length() > max ? s.substring(0, max - 3) + "..." : s;
    }

    private static String getStackTrace(Exception e) {
        StringWriter sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        return sw.toString();
    }

    /**
     * üéØ INTERFAZ FUNCIONAL TURBO
     */
    @FunctionalInterface
    private interface SupplierTurbo<T> {
        T get() throws Exception;
    }

    /**
     * üìä CLASE PARA RESUMEN DRY-RUN
     */
    private static class ResumenDryRun {
        String className;
        String packageName;
        boolean firmasOk;
        String resumen;

        ResumenDryRun(String className, String packageName, boolean firmasOk, String resumen) {
            this.className = className;
            this.packageName = packageName;
            this.firmasOk = firmasOk;
            this.resumen = resumen;
        }
    }
    
    /**
     * üìä RESUMEN DRY-RUN TURBO - IMPLEMENTACI√ìN COMPLETA
     */
    private static void mostrarResumenDryRunTurbo(List<ResumenDryRun> resumenDryRun) {
        BITACORA_TURBO.info("üìä GENERANDO RESUMEN DRY-RUN TURBO...");
        
        System.out.println("\n" + "üìä".repeat(80));
        System.out.println("                          RESUMEN DRY-RUN TURBO");
        System.out.println("üìä".repeat(80));
        System.out.printf("%-30s %-25s %-10s %s\n", "CLASE", "PAQUETE", "FIRMAS", "RESUMEN");
        System.out.println("üìä".repeat(80));
        
        int exitos = 0;
        int advertencias = 0;
        
        for (ResumenDryRun row : resumenDryRun) {
            String firmado = row.firmasOk ? "‚úÖ" : "‚ö†Ô∏è";
            String resumenTruncado = trunc(row.resumen, 50);
            
            System.out.printf("%-30s %-25s %-10s %s\n", 
                row.className, row.packageName, firmado, resumenTruncado);
            
            if (row.firmasOk) {
                exitos++;
            } else {
                advertencias++;
            }
        }
        
        System.out.println("üìä".repeat(80));
        
        // üìà ESTAD√çSTICAS
        double tasaExito = resumenDryRun.isEmpty() ? 0 : (double) exitos / resumenDryRun.size() * 100;
        
        System.out.println("üéØ ESTAD√çSTICAS DEL DRY-RUN:");
        System.out.println("  ‚Ä¢ Total clases analizadas: " + resumenDryRun.size());
        System.out.println("  ‚Ä¢ Clases con firmas v√°lidas: " + exitos + " ‚úÖ");
        System.out.println("  ‚Ä¢ Clases con advertencias: " + advertencias + " ‚ö†Ô∏è");
        System.out.println("  ‚Ä¢ Tasa de √©xito: " + String.format("%.1f%%", tasaExito));
        
        // üíæ GUARDAR RESUMEN
        try {
            StringBuilder reporte = new StringBuilder();
            reporte.append("# üìä RESUMEN DRY-RUN TURBO\n\n");
            reporte.append("## üìà ESTAD√çSTICAS\n");
            reporte.append("- Total clases: ").append(resumenDryRun.size()).append("\n");
            reporte.append("- √âxitos: ").append(exitos).append("\n");
            reporte.append("- Advertencias: ").append(advertencias).append("\n");
            reporte.append("- Tasa √©xito: ").append(String.format("%.1f%%", tasaExito)).append("\n\n");
            
            reporte.append("## üìã DETALLE POR CLASE\n");
            reporte.append("| Clase | Paquete | Firmas | Resumen |\n");
            reporte.append("|-------|---------|--------|---------|\n");
            
            for (ResumenDryRun row : resumenDryRun) {
                String firmas = row.firmasOk ? "‚úÖ" : "‚ö†Ô∏è";
                reporte.append("| ").append(row.className)
                       .append(" | ").append(row.packageName)
                       .append(" | ").append(firmas)
                       .append(" | ").append(trunc(row.resumen, 100))
                       .append(" |\n");
            }
            
            FileUtils.writeToFile("autogen-output/analisis/dry-run-resumen.md", reporte.toString());
            BITACORA_TURBO.exito("Resumen dry-run guardado en autogen-output/analisis/dry-run-resumen.md");
            
        } catch (Exception e) {
            BITACORA_TURBO.error("Error guardando resumen dry-run", e);
        }
    }
    
    /**
     * üîß REPARACI√ìN DE EMERGENCIA DEL SISTEMA
     */
    private static void ejecutarReparacionEmergencia() {
        BITACORA_TURBO.info("üîß INICIANDO REPARACI√ìN DE EMERGENCIA COMPLETA...");
        
        System.out.println("\n" + "üîß".repeat(70));
        System.out.println("           REPARACI√ìN DE EMERGENCIA - TODOS LOS SISTEMAS");
        System.out.println("üîß".repeat(70));
        
        // üéØ PASO 1: REPARAR DICCIONARIO
        BITACORA_TURBO.info("üéØ PASO 1: VERIFICANDO DICCIONARIO DE TRIPULACI√ìN...");
        ejecutarConRescate(() -> {
            // Verificar que el diccionario funciona
            String testNombre = DiccionarioDeTripulacion.obtenerNombrePirata("TestClass");
            BITACORA_TURBO.info("‚úÖ Diccionario operativo: " + testNombre);
        }, "Diccionario Reparaci√≥n");
        
        // üéØ PASO 2: REPARAR SCANNER  
        BITACORA_TURBO.info("üéØ PASO 2: APLICANDO PARCHES AL PROJECT SCANNER...");
        ejecutarConRescate(() -> {
            // Aqu√≠ ir√≠a el parche espec√≠fico para el scanner
            aplicarParcheScanner();
        }, "Scanner Reparaci√≥n");
        
        // üéØ PASO 3: LIMPIAR CACHES
        BITACORA_TURBO.info("üéØ PASO 3: LIMPIANDO CACHES TEMPORALES...");
        ejecutarConRescate(() -> {
            // Limpiar archivos temporales que puedan causar problemas
            FileUtils.limpiarArchivosTemporales();
            BITACORA_TURBO.info("‚úÖ Caches limpiados");
        }, "Limpieza Caches");
        
        // üéØ PASO 4: VERIFICACI√ìN FINAL
        BITACORA_TURBO.info("üéØ PASO 4: VERIFICANDO SISTEMA REPARADO...");
        ejecutarConRescate(() -> {
            verificarSistemaReparado();
        }, "Verificaci√≥n Final");
        
        BITACORA_TURBO.exito("üéä REPARACI√ìN DE EMERGENCIA COMPLETADA");
        System.out.println("\nüöÄ ¬°Sistema reparado y listo para la acci√≥n!");
        System.out.println("üîß".repeat(70));
    }

    /**
     * üõ†Ô∏è APLICAR PARCHES ESPEC√çFICOS AL SCANNER
     */
    private static void aplicarParcheScanner() {
        System.out.println("\nüîß APLICANDO PARCHES AL PROJECT SCANNER...");
        
        // Parche 1: Configuraci√≥n robusta
        System.out.println("üéØ Configurando parser tolerante a errores...");
        
        // Parche 2: Manejo de archivos problem√°ticos  
        System.out.println("üéØ Implementando sistema de archivos omitidos...");
        
        // Parche 3: Recuperaci√≥n elegante
        System.out.println("üéØ A√±adiendo estrategias de rescate...");
        
        BITACORA_TURBO.info("‚úÖ Parches aplicados al scanner");
    }

    /**
     * ‚úÖ VERIFICAR SISTEMA REPARADO
     */
    private static void verificarSistemaReparado() {
        System.out.println("\n‚úÖ VERIFICANDO SISTEMA REPARADO...");
        
        // Verificar componentes cr√≠ticos
        System.out.println("üéØ Bit√°cora: " + (BITACORA_TURBO != null ? "‚úÖ OPERATIVA" : "‚ùå FALLIDA"));
        System.out.println("üéØ Scanner: " + (SCANNER_AVANZADO != null ? "‚úÖ OPERATIVO" : "‚ùå FALLIDO"));
        System.out.println("üéØ Integrador: " + (INTEGRADOR_TURBO != null ? "‚úÖ OPERATIVO" : "‚ùå FALLIDO"));
        
        // Verificar archivos esenciales
        System.out.println("üéØ Directorio output: " + (new File("autogen-output").exists() ? "‚úÖ EXISTE" : "‚ùå FALTANTE"));
        
        BITACORA_TURBO.info("‚úÖ Verificaci√≥n del sistema completada");
    }
    
    /**
     * üîç DIAGN√ìSTICO DE FORMATOS PROBLEM√ÅTICOS
     */
    /**
     * üîç DIAGN√ìSTICO DE FORMATOS PROBLEM√ÅTICOS
     */
    private static void ejecutarDiagnosticoFormatos() {
        BITACORA_TURBO.info("üîç INICIANDO DIAGN√ìSTICO DE FORMATOS PROBLEM√ÅTICOS...");
        
        try {
            // Revisar archivos en busca de cadenas de formato problem√°ticas
            List<String> archivosConProblemas = new ArrayList<>();
            
            Files.walk(Paths.get(PROJECT_PATH))
                .filter(path -> path.toString().endsWith(".java"))
                .forEach(path -> {
                    try {
                        String contenido = Files.readString(path);
                        if (contenido.contains("%V") || contenido.contains("%v")) {
                            archivosConProblemas.add(path.toString());
                            BITACORA_TURBO.warn("‚ö†Ô∏è Posible formato problem√°tico en: " + path);
                        }
                    } catch (IOException e) {
                        // Ignorar errores de lectura
                    }
                });
            
            if (!archivosConProblemas.isEmpty()) {
                BITACORA_TURBO.error("üö® ARCHIVOS CON POSIBLES FORMATOS PROBLEM√ÅTICOS:");
                archivosConProblemas.forEach(archivo -> {
                    BITACORA_TURBO.error("  ‚Ä¢ " + archivo);
                });
                
                // Guardar reporte
                String reporte = "Archivos con posibles formatos problem√°ticos:\n" +
                    String.join("\n", archivosConProblemas);
                FileUtils.writeToFile("autogen-output/diagnosticos/formatos-problematicos.md", reporte);
            } else {
                BITACORA_TURBO.exito("‚úÖ No se encontraron formatos problem√°ticos evidentes");
            }
            
        } catch (Exception e) {
            BITACORA_TURBO.error("Error en diagn√≥stico de formatos", e);
        }
    }

    /**
     * üîß REPARACI√ìN DE FORMATOS PROBLEM√ÅTICOS - MEJORADO
     */
    private static void ejecutarReparacionFormatos() {
        BITACORA_TURBO.info("üîß INICIANDO REPARACI√ìN DE FORMATOS PROBLEM√ÅTICOS...");
        
        ejecutarConRescate(() -> {
            int archivosReparados = 0;
            
            try {
                // Buscar y reparar formatos %V problem√°ticos
                List<Path> archivosJava = Files.walk(Paths.get(PROJECT_PATH))
                    .filter(path -> path.toString().endsWith(".java"))
                    .collect(Collectors.toList());
                
                BITACORA_TURBO.info("üîç Analizando " + archivosJava.size() + " archivos Java...");
                    
                for (Path archivo : archivosJava) {
                    try {
                        String contenido = Files.readString(archivo);
                        String contenidoOriginal = contenido;
                        
                        // Reparar formatos problem√°ticos
                        contenido = contenido.replace("%V", "%s")  // Reemplazar %V por %s
                                           .replace("%v", "%s");  // Reemplazar %v por %s
                        
                        if (!contenido.equals(contenidoOriginal)) {
                            // Crear backup antes de modificar
                            Path backup = Paths.get(archivo.toString() + ".backup");
                            Files.copy(archivo, backup, StandardCopyOption.REPLACE_EXISTING);
                            
                            // Escribir archivo reparado
                            Files.writeString(archivo, contenido);
                            archivosReparados++;
                            BITACORA_TURBO.info("‚úÖ Reparado: " + archivo.getFileName());
                        }
                        
                    } catch (Exception e) {
                        BITACORA_TURBO.warn("‚ö†Ô∏è No se pudo procesar: " + archivo);
                    }
                }
                
                if (archivosReparados > 0) {
                    BITACORA_TURBO.exito("üîß Reparaci√≥n completada: " + archivosReparados + " archivos modificados");
                } else {
                    BITACORA_TURBO.info("‚ÑπÔ∏è No se encontraron formatos problem√°ticos para reparar");
                }
                
            } catch (IOException e) {
                BITACORA_TURBO.error("‚ùå Error accediendo a los archivos", e);
            }
            
        }, "Reparaci√≥n de Formatos");
    }

}